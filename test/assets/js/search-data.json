{"0": {
    "doc": "Code solution",
    "title": "Solution",
    "content": "while True: if button.value is True: if current_state is state_wait: keyboard.press(key) # Send our defined key as a command... print(\"button is pressed\") #Print a confirmation in the serial monitor keyboard.release_all() # and release all keys again current_state = state_button_is_pressed # Update our state elif button.value is False: if current_state is state_button_is_pressed: print(\"button is released\") # Print a confirmation in the serial monitor current_state = state_wait # Reset the state # Sleep for a bit to make the keypress events occur at a human timescale # Skilled gamers can do ~7 button presses per second (says ChatGPT) so # we sample with twice that frequency to adher to the Nyquist rate. time.sleep(0.07) . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/code_solution.html#solution",
    
    "relUrl": "/assignments/03-game-controller-hw-code/code_solution.html#solution"
  },"1": {
    "doc": "Code solution",
    "title": "Code solution",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/code_solution.html",
    
    "relUrl": "/assignments/03-game-controller-hw-code/code_solution.html"
  },"2": {
    "doc": "Code instructions",
    "title": "Variables",
    "content": "A variable is like a box that stores information for your program. You can declare a variable and give it a value, and later change that value if needed. score = 5 # Declares a variable named \"score\" and assigns it a value of 5 score = 6 # Updates the value of \"score\" to 6 . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/coding_instructions.html#variables",
    
    "relUrl": "/assignments/03-game-controller-hw-code/coding_instructions.html#variables"
  },"3": {
    "doc": "Code instructions",
    "title": "If-Else statements",
    "content": "if , elif and else statements help your program choose between different actions based on conditions. current_state = 0 if buttun_pressed is True: current_state = 1 else: current_state = 0 . In the previous example our code checks whether the button has been pressed, if that’s the case then current_state will be updated to have value 1. Here’s how to use each statement: . | if: States the First condition, can be used on its own | else: States the Last and fallback condition, must either follow an if or elif | elif: States an alternative condition after an if, must either follow an if or elif | . The main difference between else and elif is that elif can have condition parameters, while else cannot, for example: . condition = False if condition is True: print('Condition satisfied!') elif button_is_pressed is True: print('Button is pressed!') else: print('Idle') . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/coding_instructions.html#if-else-statements",
    
    "relUrl": "/assignments/03-game-controller-hw-code/coding_instructions.html#if-else-statements"
  },"4": {
    "doc": "Code instructions",
    "title": "While loops",
    "content": "While loops are parts of code that are repeated, like the name suggests, while a certain condition is satisfied . while button_is_pressed: print('Button is pressed!') # Print while button is pressed button_is_pressed = button.value # Detect button press . Keep in mind that only the code inside the while block will be executed as long as the condition is satisfied, thus it’s important to update the variable checking the condition if we want to exit the loop at some point. Small note: writing button_is_pressed is True and button_is_pressed is essentially the same thing, although the first one makes it easier to understand the code while reading it. The most common while loop you will see during this course is the while True: loop. This loop defines the behavior that your code will keep repeating while it’s on. Remember to always include time.sleep(0.1) at the end of your while True: loop, this prevents it to execute your code too fast and overwhelm the board. while True: # Your code logic here.... time.sleep(0.1) . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/coding_instructions.html#while-loops",
    
    "relUrl": "/assignments/03-game-controller-hw-code/coding_instructions.html#while-loops"
  },"5": {
    "doc": "Code instructions",
    "title": "Code instructions",
    "content": "Coding can look like a super complicated skill to learn, but if we decompose each component and learn them individually it can turn out to be quite easy! . In this tutorial we will present 3 basic components, mainly: . | Variables -&gt; Used for storing values | If-else statements -&gt; Used for decision making | While loops -&gt; Used to easily repeat operations | . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/coding_instructions.html",
    
    "relUrl": "/assignments/03-game-controller-hw-code/coding_instructions.html"
  },"6": {
    "doc": "Fading and blinking a Chainable LED",
    "title": "Fading and blinking a Chainable LED",
    "content": "This example used the Chainable LED of the Connected Interaction Kit, connected to D6 of the Expander Board. ##--- Library Imports import time import board import neopixel from varspeed import Vspeed ##--- VarSpeed Variables MIN = 0.0 # The minimum possible value of our component MAX = 1.0 # The maximum possible value of our component vs = Vspeed(init_position=MIN, result=\"float\") # init_position = initial start position // result = float, int vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # make the output of the function be within the bounds set ##--- Hardware Setup pin_leds = board.D6 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, brightness=0.5, auto_write=False, pixel_order=neopixel.GRBW) ##--- Custom Movement Sequence # This is where we can define the brightness of our LED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] # Define what should happen when we get to the end of our sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times leds.fill((0, 255, 0)) # Color the LED green leds.show() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position, running, changed = vs.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed: print( f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') leds.brightness = position leds.show() . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led-index.html",
    
    "relUrl": "/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led-index.html"
  },"7": {
    "doc": "Game code for ChaiNEO",
    "title": "Reaction Game",
    "content": "In this weeks assignment we are going to build a simple reaction game and embody it in different shapes and forms. ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/game_code_neopixel.html#reaction-game",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/game_code_neopixel.html#reaction-game"
  },"8": {
    "doc": "Game code for ChaiNEO",
    "title": "Game logic and hardware involved",
    "content": "The basic game makes use of two input components (either Touch Sensor or Tactile Switch), and a Chainable RGB LED as an output. Once the LED turns white, both players have to try and touch their sensor as quick as possible. Whoever is faster wins the round, and the LED will light up in the corresponding color. ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/game_code_neopixel.html#game-logic-and-hardware-involved",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/game_code_neopixel.html#game-logic-and-hardware-involved"
  },"9": {
    "doc": "Game code for ChaiNEO",
    "title": "Connecting the cables",
    "content": "Your ItsyBitsy has several connection ports on it. To be sure that your code works properly, you need to make sure that the ports to which you connected your components are the same used in your code. For example, if you connect a component to port D7, you need to use the following code to reference it: . | | . ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/game_code_neopixel.html#connecting-the-cables",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/game_code_neopixel.html#connecting-the-cables"
  },"10": {
    "doc": "Game code for ChaiNEO",
    "title": "Code for the game",
    "content": "We provide you with the basic code for the game. Copy this code into your code.py file and connect all hardware components to have a basic game ready. Look through the code and use the examples from the previous section to deduce where to connect your components! . | PicoExpander | BitsyExpander | . | ##--- Imports import digitalio import board import neopixel import time import random ##--- Variables state_wait = 0 state_start_game = 1 state_wait_button_press = 2 state_red_wins = 3 state_blue_wins = 4 current_state = 0 # Button variables red_pin = board.GP6 red_button = digitalio.DigitalInOut(red_pin) red_button.direction = digitalio.Direction.INPUT blue_pin = board.GP8 blue_button = digitalio.DigitalInOut(blue_pin) blue_button.direction = digitalio.Direction.INPUT # For the Chainable LED: pin_leds = board.GP10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_blue = (0, 0, 255, 0) led_white = (0, 0, 0, 255) # Timer variables timer_duration = 0 timer_mark = 0 ##--- Functions def set_led_color(color): global leds leds.fill(color) leds.show() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Main loop while True: if current_state == state_wait: set_led_color(led_off) set_timer(random.randint(3, 10)) print(\"starting game!\") current_state = state_start_game elif current_state == state_start_game: if timer_expired(): print(\"timer expired, press your buttons!\") set_led_color(led_white) current_state = state_wait_button_press elif current_state == state_wait_button_press: if red_button.value: print(\"red won\") current_state = state_red_wins elif blue_button.value: print(\"blue won\") current_state = state_blue_wins elif current_state == state_blue_wins: set_led_color(led_blue) time.sleep(3) current_state = state_wait elif current_state == state_red_wins: set_led_color(led_red) time.sleep(3) current_state = state_wait . | ##--- Imports import digitalio import board import neopixel import time import random ##--- Variables state_wait = 0 state_start_game = 1 state_wait_button_press = 2 state_red_wins = 3 state_blue_wins = 4 current_state = 0 # Button variables red_pin = board.D7 red_button = digitalio.DigitalInOut(red_pin) red_button.direction = digitalio.Direction.INPUT blue_pin = board.D13 blue_button = digitalio.DigitalInOut(blue_pin) blue_button.direction = digitalio.Direction.INPUT # For the Chainable LED: pin_leds = board.D3 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_blue = (0, 0, 255, 0) led_white = (0, 0, 0, 255) # Timer variables timer_duration = 0 timer_mark = 0 ##--- Functions def set_led_color(color): global leds leds.fill(color) leds.show() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Main loop while True: if current_state == state_wait: set_led_color(led_off) set_timer(random.randint(3, 10)) print(\"starting game!\") current_state = state_start_game elif current_state == state_start_game: if timer_expired(): print(\"timer expired, press your buttons!\") set_led_color(led_white) current_state = state_wait_button_press elif current_state == state_wait_button_press: if red_button.value: print(\"red won\") current_state = state_red_wins elif blue_button.value: print(\"blue won\") current_state = state_blue_wins elif current_state == state_blue_wins: set_led_color(led_blue) time.sleep(3) current_state = state_wait elif current_state == state_red_wins: set_led_color(led_red) time.sleep(3) current_state = state_wait . | . ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/game_code_neopixel.html#code-for-the-game",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/game_code_neopixel.html#code-for-the-game"
  },"11": {
    "doc": "Game code for ChaiNEO",
    "title": "Game code for ChaiNEO",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/game_code_neopixel.html",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/game_code_neopixel.html"
  },"12": {
    "doc": "Game code for Grove",
    "title": "Reaction Game",
    "content": "In this weeks assignment we are going to build a simple reaction game and embody it in different shapes and forms. ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/game_code_p9813.html#reaction-game",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/game_code_p9813.html#reaction-game"
  },"13": {
    "doc": "Game code for Grove",
    "title": "Game logic and hardware involved",
    "content": "The basic game makes use of two input components (either Touch Sensor or Tactile Switch), and a Chainable RGB LED as an output. Refer to the component page for the Grove Chainable RGB LED , to obtain the P9813.py Python module. Once the LED turns white, both players have to try and touch their sensor as quick as possible. Whoever is faster wins the round, and the LED will light up in the corresponding color. ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/game_code_p9813.html#game-logic-and-hardware-involved",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/game_code_p9813.html#game-logic-and-hardware-involved"
  },"14": {
    "doc": "Game code for Grove",
    "title": "Connecting the cables",
    "content": "Your ItsyBitsy has several connection ports on it. To be sure that your code works properly, you need to make sure that the ports to which you connected your components are the same used in your code. For example, if you connect a component to port D7, you need to use the following code to reference it: . | | . ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/game_code_p9813.html#connecting-the-cables",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/game_code_p9813.html#connecting-the-cables"
  },"15": {
    "doc": "Game code for Grove",
    "title": "Code for the game",
    "content": "We provide you with the basic code for the game. Copy this code into your code.py file and connect all hardware components to have a basic game ready. Look through the code and use the examples from the previous section to deduce where to connect your components! . | PicoExpander | BitsyExpander | . | ##--- Imports import digitalio import board import p9813 import time import random ##--- Variables state_wait = 0 state_start_game = 1 state_wait_button_press = 2 state_red_wins = 3 state_blue_wins = 4 current_state = 0 # Button variables red_pin = board.D7 red_button = digitalio.DigitalInOut(red_pin) red_button.direction = digitalio.Direction.INPUT blue_pin = board.D13 blue_button = digitalio.DigitalInOut(blue_pin) blue_button.direction = digitalio.Direction.INPUT # For the Chainable LED: pin_clk = board.D3 pin_data = board.D4 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) led_off = (0, 0, 0) led_red = (255, 0, 0) led_blue = (0, 0, 255) led_white = (255, 255, 255) # Timer variables timer_duration = 0 timer_mark = 0 ##--- Functions def set_led_color(color): global leds leds.fill(color) leds.write() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Main loop while True: if current_state == state_wait: set_led_color(led_off) set_timer(random.randint(3, 10)) print(\"starting game!\") current_state = state_start_game elif current_state == state_start_game: if timer_expired(): print(\"timer expired, press your buttons!\") set_led_color(led_white) current_state = state_wait_button_press elif current_state == state_wait_button_press: if red_button.value: print(\"red won\") current_state = state_red_wins elif blue_button.value: print(\"blue won\") current_state = state_blue_wins elif current_state == state_blue_wins: set_led_color(led_blue) time.sleep(3) current_state = state_wait elif current_state == state_red_wins: set_led_color(led_red) time.sleep(3) current_state = state_wait . | ##--- Imports import digitalio import board import p9813 import time import random ##--- Variables state_wait = 0 state_start_game = 1 state_wait_button_press = 2 state_red_wins = 3 state_blue_wins = 4 current_state = 0 # Button variables red_pin = board.GP6 red_button = digitalio.DigitalInOut(red_pin) red_button.direction = digitalio.Direction.INPUT blue_pin = board.GP8 blue_button = digitalio.DigitalInOut(blue_pin) blue_button.direction = digitalio.Direction.INPUT # For the Chainable LED: pin_clk = board.GP10 pin_data = board.GP11 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) led_off = (0, 0, 0) led_red = (255, 0, 0) led_blue = (0, 0, 255) led_white = (255, 255, 255) # Timer variables timer_duration = 0 timer_mark = 0 ##--- Functions def set_led_color(color): global leds leds.fill(color) leds.write() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Main loop while True: if current_state == state_wait: set_led_color(led_off) set_timer(random.randint(3, 10)) print(\"starting game!\") current_state = state_start_game elif current_state == state_start_game: if timer_expired(): print(\"timer expired, press your buttons!\") set_led_color(led_white) current_state = state_wait_button_press elif current_state == state_wait_button_press: if red_button.value: print(\"red won\") current_state = state_red_wins elif blue_button.value: print(\"blue won\") current_state = state_blue_wins elif current_state == state_blue_wins: set_led_color(led_blue) time.sleep(3) current_state = state_wait elif current_state == state_red_wins: set_led_color(led_red) time.sleep(3) current_state = state_wait . | . ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/game_code_p9813.html#code-for-the-game",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/game_code_p9813.html#code-for-the-game"
  },"16": {
    "doc": "Game code for Grove",
    "title": "Game code for Grove",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/game_code_p9813.html",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/game_code_p9813.html"
  },"17": {
    "doc": "02 Pomodoro",
    "title": "02 Pomodoro Timer",
    "content": "In this tutorial, you will learn how to build a Pomodoro Timer. The Pomodoro Technique is a time management technique that allows you to take regular breaks when working on a task. We will use CircuitPython as programming language, and use Mu Editor as our programming environment. Get Started . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/#02-pomodoro-timer",
    
    "relUrl": "/tutorials/02-pomodoro/#02-pomodoro-timer"
  },"18": {
    "doc": "02 Pomodoro",
    "title": "02 Pomodoro",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/",
    
    "relUrl": "/tutorials/02-pomodoro/"
  },"19": {
    "doc": "01 Time in CircuitPython",
    "title": "Dealing with Time in Circuit Python",
    "content": "You often need to take time into account one way or another when writing programs. The Core Module called time can help us with this! It has a few more bits of functionality than I will describe here (check the documentation if you’re interested). I will focus on the most important and fundamental functions, which are also very useful for the type of thing’s you might be doing. time.sleep(seconds_as_floating_point) [returns nothing] . This function is very easy to use and is sometimes the right approach - but often it’s not! . | This makes the processor (and hence the program) stop at that line and wait for the specified amount of time. | This is a simple way to introduce a delay of known duration between two steps. | Think of it like the count-down timer on your phone. When the code gets to that line, it set’s a timer for the specified time, then goes to sleep until the timer ‘beeps’, it which point it wakes up and keeps going. | The problem is that the processor can’t do anything else (with a few exceptions, e.g. it will still detect and count pulses using countio) during this time. So it’s a waste of processor power, and prevents the program from responding to anything else during that time. | For a sufficiently simple program the waste of time might not be an issue, and in some circumstances it’s ok that the system becomes unresponsive for a short while, so it can be a valid solution in some cases, particularly where very short delays are used. | . time.monotonic() [returns time_in_seconds_as_floating_point] or the time.monotonic_ns() [returns time_in_nanosecons_as_long_integer] . are often a better way of doing time related stuff. But it takes a little bit more thought and coding to make use of them. Calling either of these functions can be thought of as consulting a stop-watch that is always running and counting up. The actual value is meaningless because the starting point is arbitrary, but that doesn’t matter if you look at the difference between two readings taken at different times. Difference between time.monotonic() and time.monotonic_ns() . is just down to how time is represented: . | With “time.monotonic()” you get a floating point number that represents time in seconds. Having the number in seconds is often convenient, because it’s a fairly intuitive measure of time. | Due to the way floating point numbers are represented: an arbitrarily large number can be represented; but the precision that can be represented decreases as the number gets bigger. Initially you get precision of 1ms or better, but after an hour and a bit that will start decreasing (first to 2ms, then 4ms and so on). | So, if you need sub-millisecond precision, or if you need millisecond precision over fairly long periods, this is not the one to use. | With “time.monotonic_ns()” you get an integer that represents the time in nanoseconds (1 second = 1,000,000,000 nanoseconds = 1e9 nanoseconds). This is obviously a less intuitive measure of time. | Due to the way integers are handled by Python (this is not the case in many other languages like C++), there is no specific limit to the size of number that can be represented. As the number gets bigger, more and more memory will be allocated to represent it. Of course, eventually the board will run out of memory, but that would take quite an extreme situation. | So, using this approach will give you much finer time resolution that never deteriorates, but at the expense of more memory and, possibly, a slightly higher CPU load for doing the necessary sums. | Also note: even though it represents time in nanoseconds, don’t expect to be able to use resolution that fine. The CPU is only 120MHz, so each CPU clock cycle is going to take around 10ns, and most Python commands are going to take multiple clock cycles to complete. So probably stick to microseconds or longer! | . Illustrative Examples Involving Time . To illustrate these concepts, we will consider two examples: blinking an LED, and detecting a “double click” of a button. The associated programs are provided. ",
    "url": "/Digital-Interfaces/test/tutorials/01-time/#dealing-with-time-in-circuit-python",
    
    "relUrl": "/tutorials/01-time/#dealing-with-time-in-circuit-python"
  },"20": {
    "doc": "01 Time in CircuitPython",
    "title": "Example 1: Blink an LED",
    "content": "Two programs are provided, both of which make the on-board LED blink at 1Hz and 50% duty cycle (i.e. on for 500ms, off for 500ms and so on). Program 1: using time.sleep() . The first program (“LED blink using sleep.py”) does this using time.sleep(): it turns on the LED, sleeps for 500ms, turns off the LED, sleeps for 500ms and repeats. (See the detailed comments in the code for further explanation) . | This works totally fine if you just want to make one LED blink (how exciting!). | But what if you had two LEDs that you wanted to blink at different frequencies? Or what if you simply wanted the microcontroller to do something else while the LED was blinking? | In this case, both of those things would be impossible. The processor spends 99,9999…% of its time sleeping! | . # Import the required libraries: # - board: Provides pin definitions specific to the board being used. # - digitalio: Provides digital input/output functionality. # - time: Provides time-related functions, such as sleep(). import board import digitalio import time # Create a DigitalInOut object for the onboard LED. led = digitalio.DigitalInOut(board.LED) # Set the direction of the 'led' object as OUTPUT, allowing us to control the LED state. led.direction = digitalio.Direction.OUTPUT # Start an infinite loop to repeatedly execute the code within. while True: # Set the LED value to True, which turns it ON. led.value = True # Pause the program execution for 0.5 seconds (500 milliseconds) while the LED remains ON. time.sleep(0.5) # Set the LED value to False, which turns it OFF. led.value = False # Pause the program execution for 0.5 seconds (500 milliseconds) while the LED remains OFF. time.sleep(0.5) # The loop will repeat, causing the LED to blink on and off every half second. Program 2: using time.monotonic() . The second program (“LED blink using time monotonic.py”) achieves the same thing using time.monotonic(): it notes the last time it changed the LED state, keeps looping and checking the time, and changes the state again when enough time has passed (See the detailed comments in the code for further explanation) . | The resulting LED behaviour is identical to the previous example. | In this very simple case, the processor spends 99.999…% of its time checking the ‘stopwatch’ and calculating whether enough time has passed. | However, the key difference is that you could add much more code inside the while loop, and it would do that between ‘stopwatch checks’. As long as that code takes much less than 500ms to execute (which would almost always be the case - it’s pretty hard to keep a microcontroller busy for 500ms without telling it to wait!), then the blinking would continue. | See the third program (“LED blink using time monotonic multiple LEDs.py”) for an example where the program is extended to blink two LEDs at different frequencies, assuming one is connected to D1 and the other to D2. | . # Import the required libraries: # - board: Provides pin definitions specific to the board being used. # - digitalio: Provides digital input/output functionality. # - time: Provides time-related functions, such as monotonic() and sleep(). import board import digitalio import time # Create a DigitalInOut object for the onboard LED. led = digitalio.DigitalInOut(board.LED) # Set the direction of the 'led' object as OUTPUT, allowing us to control the LED state. led.direction = digitalio.Direction.OUTPUT # Set the blink rate for the LED (in seconds). In this case, 0.5 seconds. blinkRateLED = 0.5 # Initialize the LED state to False (off). led.value = False # Record the current time using time.monotonic() as the last time the LED state was changed. lastChangeTimeLED = time.monotonic() # Start an infinite loop to repeatedly execute the code within. while True: # Get the current time using time.monotonic(). timeNow = time.monotonic() # Check if the time elapsed since the last LED state change is greater than the blink rate. if timeNow - lastChangeTimeLED &gt; blinkRateLED: # Invert the LED state using the 'not' keyword. led.value = not led.value # Update the last LED state change time to the current time. lastChangeTimeLED = timeNow . ",
    "url": "/Digital-Interfaces/test/tutorials/01-time/#example-1-blink-an-led",
    
    "relUrl": "/tutorials/01-time/#example-1-blink-an-led"
  },"21": {
    "doc": "01 Time in CircuitPython",
    "title": "Example 2: Detecting “double click” of a button",
    "content": "Background information . | As an illustrative example that might also be useful at some point, here we build up to a program that can tell the difference between a “single click” and a “double click”, just like with a computer mouse. | I prototyped this using the “Touch Sensor” module from the Connected Interaction Kit. The code could also be applied to a conventional mechanical button, but some modification might be required to address the issue of “bouncing”. | . Switch bouncing . Switch bouncing, also known as contact bouncing, is a common issue in electronics where a mechanical switch’s contacts do not instantly make or break a connection when the switch is actuated. Instead, the contacts rapidly open and close several times before settling, causing multiple unintended transitions in the signal. This can lead to false readings or undesired behavior in digital circuits or microcontrollers interpreting the switch’s state. | To address this issue, switch debouncing techniques, such as software-based delays or hardware-based filters, are used to ensure stable and accurate signal transitions. | The Touch Sensor module includes hardware debouncing so it gives a very clean signal. | We won’t go further into the issue of debouncing here, so just use the Touch Sensor for now. | . Program 1: most basic way . The first program (“Button basic.py”) is just included to show the most basic way to control an LED from a button. The LED mirrors the state of the button, so it’s on while you hold the button. See comments in the program for more detailed explanation. # Import the required libraries: # - board: Provides pin definitions specific to the board being used. # - digitalio: Provides digital input/output functionality. # - time: Provides time-related functions, such as sleep(). import board import digitalio import time # Create a DigitalInOut object for the onboard LED. led = digitalio.DigitalInOut(board.LED) # Set the direction of the 'led' object as OUTPUT, allowing us to control the LED state. led.direction = digitalio.Direction.OUTPUT # Create a DigitalInOut object for the button, connected to pin D6. button = digitalio.DigitalInOut(board.D6) # Set the direction of the 'button' object as INPUT, allowing us to read its state. button.direction = digitalio.Direction.INPUT # Start an infinite loop to repeatedly execute the code within. while True: # Read the current button state and set the LED state to match the button state. # If the button is pressed (True), the LED will turn ON. # If the button is not pressed (False), the LED will turn OFF. led.value = button.value . Program 2: edge detection . The second program (“Button toggle single click.py) introduces the concept of edge detection. It specifically monitors to changes from low to high in the state of the button. Each time this occurs, it toggles the state of the LED (i.e. turns it on if it was off and vice versa). Again, this is explained in more detail in the comments in the code. # Import the required libraries: # - board: Provides pin definitions specific to the board being used. # - digitalio: Provides digital input/output functionality. # - time: Provides time-related functions, such as sleep(). import board import digitalio import time # Create a DigitalInOut object for the onboard LED. led = digitalio.DigitalInOut(board.LED) # Set the direction of the 'led' object as OUTPUT, allowing us to control the LED state. led.direction = digitalio.Direction.OUTPUT # Create a DigitalInOut object for the button, connected to pin D6. button = digitalio.DigitalInOut(board.D6) # Set the direction of the 'button' object as INPUT, allowing us to read its state. button.direction = digitalio.Direction.INPUT # Initialize variables to store the last button state and the current LED state. lastButton = False LEDstate = False # Start an infinite loop to repeatedly execute the code within. while True: # Read the current button state and store it in the newButton variable. newButton = button.value # Check for a rising edge (change from low to high) on the button input. if newButton and not lastButton: # If a rising edge is detected, toggle the LED state using the 'not' keyword. LEDstate = not LEDstate # Update the last button state to the current button state. lastButton = newButton # Set the LED state according to the value of LEDstate. led.value = LEDstate . Program 3: button toggle using time module . Finally, the third program (“Button toggle only on double click.py”) uses the time module (specifically the time.monotonic() function) to differentiate between a “double click” (two clicks in sufficiently quick succession – 250ms in the provided code) and one or more “single clicks”. It only toggles the LED state on a double click, but it prints “Single Click” or “Double Click” to the serial monitor. If you were using this as part of a larger program, you could do different actions on the single and double clicks. This one is fairly complicated, but the comments in the code explain in detail. # Import the required libraries: import board import digitalio import time # Create a DigitalInOut object for the onboard LED. led = digitalio.DigitalInOut(board.LED) led.direction = digitalio.Direction.OUTPUT # Set LED as output # Create a DigitalInOut object for the button, connected to pin D6. button = digitalio.DigitalInOut(board.D6) button.direction = digitalio.Direction.INPUT # Set button as input # Initialize variables to track button and LED state, as well as click detection lastButton = False LEDstate = False oneClick = False clickTime = 0 doubleClickWindow = 0.25 # Time window for double-click detection (in seconds) # Start an infinite loop to repeatedly execute the code within. while True: newButton = button.value # Read the current button state # Check for a rising edge (change from low to high) on the button input. if newButton and not lastButton: # If this is the first click, set oneClick to True and save the current time. if not oneClick: oneClick = True clickTime = time.monotonic() # If oneClick is already True, a second click has been detected within the time window. else: print(\"Double Click\") # Detected a double-click oneClick = False # Reset oneClick for future click detection LEDstate = not LEDstate # Toggle the LED state (if ON, turn OFF; if OFF, turn ON) # Update the last button state to the current button state. lastButton = newButton # Check if the time since the first click has exceeded the double-click window # and oneClick is still True (meaning a second click has not been detected). if time.monotonic() - clickTime &gt; doubleClickWindow and oneClick: print(\"Single Click\") # Detected a single-click oneClick = False # Reset oneClick for future click detection # Set the LED state according to the value of LEDstate. led.value = LEDstate . ",
    "url": "/Digital-Interfaces/test/tutorials/01-time/#example-2-detecting-double-click-of-a-button",
    
    "relUrl": "/tutorials/01-time/#example-2-detecting-double-click-of-a-button"
  },"22": {
    "doc": "01 Time in CircuitPython",
    "title": "01 Time in CircuitPython",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/01-time/",
    
    "relUrl": "/tutorials/01-time/"
  },"23": {
    "doc": "Coding Challenge",
    "title": "Coding Challenge - Sound sensitive light",
    "content": "This section is not a full tutorial but more a challenge of you coding skills. You will be building an increasingly more complicated sound activated LED. Every step consists of the following: . | A detailed explanation of what the end result of this step should be. | A button that leads to a page with the solution. | . We really encourage you to try before taking a peak at the hints and solution. If you get stuck on a step then don’t forget to check the solutions to a previous step before checking the solution of the current step, as it might help you solve it on your own. ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/#coding-challenge---sound-sensitive-light",
    
    "relUrl": "/tutorials/coding-challenge/#coding-challenge---sound-sensitive-light"
  },"24": {
    "doc": "Coding Challenge",
    "title": "Step 1 - Sound activated LED",
    "content": "For the first step you are going to create a sound activated LED. For this LED we will be using the Neopixel Chainable LED and the Sound Sensor. We want the sound sensor to trigger when it’s value exceeds 30000 and the led should stay on for 1 second. The color of the LED should be a dim white with the value of (0,0,0,50). Do not forget to turn of the LED at the start of you code. Show Solution . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/#step-1---sound-activated-led",
    
    "relUrl": "/tutorials/coding-challenge/#step-1---sound-activated-led"
  },"25": {
    "doc": "Coding Challenge",
    "title": "Step 2 - No sleep for the wicked",
    "content": "There is a good change that in Step 1 you used time.sleep() in order to make the LED stay on for one second. For this next step we challenge you to improve your code to no longer use any time.sleep(). Removing the time.sleep() will allow us to preform more multitasking in the next steps. Show Solution . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/#step-2---no-sleep-for-the-wicked",
    
    "relUrl": "/tutorials/coding-challenge/#step-2---no-sleep-for-the-wicked"
  },"26": {
    "doc": "Coding Challenge",
    "title": "Step 3 - Taste the rainbow",
    "content": "For this step we want to change the behaviour of the LED. Every time the sound sensor triggers, the LED should light up with a random color. An important part of this is that for every trigger it should only pick one color. Meaning that if I were to snap my fingers and it picks a color it should only pick a new color after it has become quite again (a sensor value of less than 30000). A good way to test this is by printing every color picked to the serial monitor! . Show Solution . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/#step-3---taste-the-rainbow",
    
    "relUrl": "/tutorials/coding-challenge/#step-3---taste-the-rainbow"
  },"27": {
    "doc": "Coding Challenge",
    "title": "Step 4 - Perfect Memory",
    "content": "For our final step, we are going to add a button. When the user presses the button, the following should happen: It should show every color chosen since the board started for 1 second each. After having shown all the colors, it should forget them. So, suppose the sensor has been triggered three times since the restart and shows red, purple, and orange. In that case, if the user presses the button, it should show red for one second, purple for one second, and orange for one second. You are allowed to use time.sleep() here again. Show Solution . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/#step-4---perfect-memory",
    
    "relUrl": "/tutorials/coding-challenge/#step-4---perfect-memory"
  },"28": {
    "doc": "Coding Challenge",
    "title": "Coding Challenge",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/",
    
    "relUrl": "/tutorials/coding-challenge/"
  },"29": {
    "doc": "Tutorials",
    "title": "Tutorials",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/",
    
    "relUrl": "/tutorials/"
  },"30": {
    "doc": "7+8: Animistic Design",
    "title": "Animistic Design",
    "content": "In the coming two weeks, you will create an animistic creature — a digital interface that appears alive through different behaviors. For this final assignment, it is essential that you understand the difference between blocking and non-blocking code. ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#animistic-design",
    
    "relUrl": "/assignments/07+08-animistic-design/#animistic-design"
  },"31": {
    "doc": "7+8: Animistic Design",
    "title": "Timing Explained",
    "content": "Blocking Code . So far, most of the code you have written has been blocking. Blocking code controls time using: . time.sleep() . When time.sleep() is called, the microcontroller halts execution for the specified number of seconds. During this time: . | No inputs are read | No outputs are updated | Nothing else can happen | . This approach is fine for simple interactions, such as the Reaction Game. However, it quickly becomes a problem when your system needs to: . | Continuously update LEDs | Monitor buttons or sensors | Respond to multiple events at the same time | . Non-blocking code with time.monotonic() . To avoid blocking the program, we can use: . time.monotonic() . This function returns the number of seconds (as a floating-point value) that have passed since the Python program started running. Instead of waiting, we: . | Store a time reference | Continuously check how much time has passed | Act only when a set interval has expired | . This allows the rest of the program to keep running. Timer functions . The code below provides two helper functions for working with time-based events in a non-blocking way. Try to understand how it works before using it in your own program. # -- Import timer library import time # -- Timer functions last_timer_mark = 0 timer_duration = 0 def start_timer(duration): # Takes duration in seconds global last_timer_mark, timer_duration last_timer_mark = time.monotonic() timer_duration = duration def is_timer_expired(): # Returns True / False return (time.monotonic() - last_timer_mark) &gt; timer_duration . Key idea: The program never stops running — it only checks whether enough time has passed. Timer examples . import time start_timer(2.0) # Creates and starts a timer of 2 seconds print(is_timer_expired()) # Will print \"False\", since 2 seconds haven't passed time.sleep(3) # Wait 3 seconds print(is_timer_expired()) # Will print \"True\", since more than 2 seconds have passed . Once a timer has expired, you can always create a new timer with start_timer() — this will start a fresh timer with the duration you specify. Remember . Blocking:    “Do this, wait, then do the next thing.” Non-blocking:    “Keep checking — act when it’s time.” . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#timing-explained",
    
    "relUrl": "/assignments/07+08-animistic-design/#timing-explained"
  },"32": {
    "doc": "7+8: Animistic Design",
    "title": "Assignment goal",
    "content": "In this assignment, you will use non-blocking code to create more complex interactive behaviors. Your object must have: . | At least two opposing behavioral states (e.g., calm/agitated, shy/curious, sleeping/awake) | State changes triggered by sensor input (e.g., buttons, sliders, distance, movement) | Behaviors expressed through outputs (e.g. LEDs, sound, movement) | . This approach is essential for creating systems that feel responsive, reactive, and alive. ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#assignment-goal",
    
    "relUrl": "/assignments/07+08-animistic-design/#assignment-goal"
  },"33": {
    "doc": "7+8: Animistic Design",
    "title": "The VarSpeed library",
    "content": "Last week we experimented with timers to write non-blocking code. This allowed us to check if a button was being pressed even while fading a led. But using timers is not the only way to achieve this. A different approach involves using the *VarSpeed library. Go through the page below to learn what the VarSpeed library does and how to use it, then come back to this page once you’re done. VarSpeed Library Guide . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#the-varspeed-library",
    
    "relUrl": "/assignments/07+08-animistic-design/#the-varspeed-library"
  },"34": {
    "doc": "7+8: Animistic Design",
    "title": "Coding assignment",
    "content": "Your assignment is to design your own acting diagram and then implement it in the code. Here below we provide a code template to help you get started. ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#coding-assignment",
    
    "relUrl": "/assignments/07+08-animistic-design/#coding-assignment"
  },"35": {
    "doc": "7+8: Animistic Design",
    "title": "Code Template",
    "content": "##--- Main Loop import board import neopixel import digitalio import time import pwmio from varspeed import Vspeed # -- Define states # TODO: Change variables according to your behaviours names state_behaviour_1 = 0 state_behaviour_2 = 1 #state_behaviour_3 = 2 current_state = state_behaviour_1 # -- Initialize the NeoPixel led_pin = board.D10 led = neopixel.NeoPixel(led_pin, 1, brightness=0.5, auto_write=False, pixel_order=neopixel.GRBW) # Define basic led colors led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_green = (0, 255, 0, 0) led_blue = (0, 0, 255, 0) led_white = (0, 0, 0, 255) def set_led_color(color): global led led.fill(color) led.show() ##-- VarSpeed Variables # TODO: Change according to your component MIN = 0 # The minimum possible value of our component MAX = 255 # The maximum possible value of our component # init_position = initial start position - result = \"float\", \"int\" vs = Vspeed(init_position=MIN, result=\"int\") # make the output of the function be within the bounds set vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # TODO: Define your sequence my_sequence = [ ] # Define how many times the defined sequence should be repeated looping = 0 # play the sequence in an endless loop forever #looping = 1 # play the sequence only once #looping = 10 # play the sequence 10 times while True: # Make a call to the library and request the parameters position, running, changed = vs.sequence(sequence=my_sequence, loop_max=looping) # - Position: The new value to assign to our servo # - Running: False if the sequence is finished, True if it's still running # - Changed: False if the value hasn't changed since the last function call, True if it has # See if the values changed for the next move, then do so if changed: print(f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') # ----------------------------------------------------------------| # | # Use your own Acting Machine Diagram to program your interaction | # | # ----------------------------------------------------------------| # ---------------------------------------------- # v DO NOT CHANGE ANYTHING BELOW THIS POINT v | # ---------------------------------------------- led.show() time.sleep(0.1) . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#code-template",
    
    "relUrl": "/assignments/07+08-animistic-design/#code-template"
  },"36": {
    "doc": "7+8: Animistic Design",
    "title": "Example Code",
    "content": "Here are some examples to get you started: . Fading and blinking a Chainable LED . Running two sequences . Trigger different sequences . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#example-code",
    
    "relUrl": "/assignments/07+08-animistic-design/#example-code"
  },"37": {
    "doc": "7+8: Animistic Design",
    "title": "7+8: Animistic Design",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/",
    
    "relUrl": "/assignments/07+08-animistic-design/"
  },"38": {
    "doc": "6: Walkie-Talkie - Embodiment",
    "title": "Walkie-Talkie - Embodiment",
    "content": "In this assignment, the goal is to give the walkie-talkie you built last week a casing. You are free to explore your creativity in terms of form and interaction, as long as the device remains operable. It must be possible to press one button to open the channel and then use the other button to send a message. What you are making this week can best be described as a hybrid between a pager and a walkie-talkie. Pagers are intended to receive short, often cryptic messages (newer models can also receive text messages), whereas walkie-talkies allow for direct two-way communication. Your design conceptually sits somewhere between these two devices. | Wireless Communicators |   | . | | | . | Pager | Walkie-Talkie | . ",
    "url": "/Digital-Interfaces/test/assignments/06-walkie-talkie-embodiment/#walkie-talkie---embodiment",
    
    "relUrl": "/assignments/06-walkie-talkie-embodiment/#walkie-talkie---embodiment"
  },"39": {
    "doc": "6: Walkie-Talkie - Embodiment",
    "title": "Inspiration",
    "content": "Originally, the walkie-talkie was developed during World War II by Motorola. The earliest devices were clearly designed for military use, both in form and function. After the war, the technology branched into different application domains. Simplified and inexpensive versions were developed as children’s toys, while more robust and reliable variants were designed for professional use, such as law enforcement and security services. Even today, in the era of smartphones, walkie-talkies are still widely used. For example, hikers and hunters rely on them in remote areas where there is no cellular coverage but where short-range communication remains essential. Each of these use cases comes with its own distinct design language, as illustrated in the images below. What will be your use case, and how does it define the embodiment of your device? . | Different Types of Walkie-Talkies |   | . | | | . | The First Walkie-Talkie | Walkie-Talkies in Space!! | . | | . | Professional | Outdoorsy | . ",
    "url": "/Digital-Interfaces/test/assignments/06-walkie-talkie-embodiment/#inspiration",
    
    "relUrl": "/assignments/06-walkie-talkie-embodiment/#inspiration"
  },"40": {
    "doc": "6: Walkie-Talkie - Embodiment",
    "title": "6: Walkie-Talkie - Embodiment",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/06-walkie-talkie-embodiment/",
    
    "relUrl": "/assignments/06-walkie-talkie-embodiment/"
  },"41": {
    "doc": "1: Reaction Game - Hardware and Code",
    "title": "Reaction Game - Hardware and Code",
    "content": "In this weeks assignment we are going to build a simple reaction game. The game consists of two players that wait for a trigger signal after which the first one to push the button is the winner of the game. Your kit contains a touch sensor that can act as a button but there is only one. So in order to test your game you’ll have to borrow a touch sensor or a button from one of your fellow students or the staff. During the coming week there will be time for you to go to the PMB and assemble and solder one or two tactile switches from parts available in your Connected Interaction Kit. ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/#reaction-game---hardware-and-code",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/#reaction-game---hardware-and-code"
  },"42": {
    "doc": "1: Reaction Game - Hardware and Code",
    "title": "Coding Instructions",
    "content": "In this tutorial, you’ll learn how to set up a CircuitPython program to bring your microcontroller, buttons, and LED to life. We’ll guide you through an example designed to match the behavior outlined in the Acting Machine Diagram (shown below). Take your time to study the code and understand how everything fits together. As you work through the tutorial, you’ll explore key Python concepts such as declaring variables, using loops (while), making decisions with if and elif statements, and defining and using functions. Additionally, you’ll learn to work with the neopixel library to control LED colors, giving your prototype a vibrant and interactive feel. By the end, you’ll have an understanding of how to run code on your board, how to connect components and a rough idea of how the code is structured. ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/#coding-instructions",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/#coding-instructions"
  },"43": {
    "doc": "1: Reaction Game - Hardware and Code",
    "title": "Game hardware and control flow",
    "content": "The basic game makes use of two input components (either Touch Sensor or Tactile Switch), and a Chainable RGB LED as an output. | Touch Sensor | Tactile Switch | Chainable RGB/W (ChaiNEO) | . | | | | . |   |   |   | . Once the LED turns white, both players have to try and touch their sensor as quick as possible. Whoever is faster wins the round, and the LED will light up in the color of the winner. The image above shows the diagram representing the control flow of the game. We will go into more detail of explaining about Acting Machine Diagrams later. For now you can already interpret how the control might flow if you start in the state (circle) labeled “wait” and then traverse the transitions (arrows) from state to state. ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/#game-hardware-and-control-flow",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/#game-hardware-and-control-flow"
  },"44": {
    "doc": "1: Reaction Game - Hardware and Code",
    "title": "Connecting the cables",
    "content": "Your ItsyBitsy has several connection ports on it. To be sure that your code works properly, you need to make sure that the ports to which you connected your components are the same used in your code. For example, if you connect a component to port D7, you need to use the following code to reference it: . | | . ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/#connecting-the-cables",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/#connecting-the-cables"
  },"45": {
    "doc": "1: Reaction Game - Hardware and Code",
    "title": "Code for the game",
    "content": "We provide you with the basic code for the game. When you connect your Pico Expander board to your laptop using a micro-USB cable the device will show up as a USB drive named CIRCUITPY. On this drive there is a file called code.py. Copy the code below into your code.py file and connect all hardware components to have a basic game ready. Look through the code and use the examples from the previous section to deduce where to connect your components! If you want to know more about the workings of the Pico Expander you can visit the site of the Connected Interaction Kit. ##--- Imports import digitalio import board import neopixel import time import random ##--- Variables state_wait = 0 state_start_game = 1 state_wait_button_press = 2 state_red_wins = 3 state_blue_wins = 4 current_state = 0 # Button variables red_pin = board.D6 red_button = digitalio.DigitalInOut(red_pin) red_button.direction = digitalio.Direction.INPUT blue_pin = board.D8 blue_button = digitalio.DigitalInOut(blue_pin) blue_button.direction = digitalio.Direction.INPUT # For the Chainable LED: pin_leds = board.D10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_blue = (0, 0, 255, 0) led_white = (0, 0, 0, 255) # Timer variables timer_duration = 0 timer_mark = 0 ##--- Functions def set_led_color(color): global leds leds.fill(color) leds.show() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Main loop while True: if current_state == state_wait: set_led_color(led_off) set_timer(random.randint(3, 10)) print(\"starting game!\") current_state = state_start_game elif current_state == state_start_game: if timer_expired(): print(\"timer expired, press your buttons!\") set_led_color(led_white) current_state = state_wait_button_press elif current_state == state_wait_button_press: if red_button.value: print(\"red won\") current_state = state_red_wins elif blue_button.value: print(\"blue won\") current_state = state_blue_wins elif current_state == state_blue_wins: set_led_color(led_blue) time.sleep(3) current_state = state_wait elif current_state == state_red_wins: set_led_color(led_red) time.sleep(3) current_state = state_wait . ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/#code-for-the-game",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/#code-for-the-game"
  },"46": {
    "doc": "1: Reaction Game - Hardware and Code",
    "title": "Extra Challenge: Make It Better!",
    "content": "Congratulations on getting the basic version of the game running! Now it’s time to put on your problem-solving hats and improve the game! The code you’ve been working with has a few intentional bugs. One key challenge involves the way button presses are handled: . Hint: If you keep a button pressed before the LED turns white, you’ll always win. That doesn’t sound very fair, does it? . Your task is to identify and fix this bug so the game works as intended. Look through the code and think of how you could achieve this, maybe also penalizing a player if they press the button before the led turns white! . While improving the game already think about what kind of game you would want it to be and what kind of embodiment would support your imagined style of gameplay. Is it going to be small and table top, will it become a physical challenge, will it have a certain theme? Everything is possible as long as you can imagine and realise it. ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/#extra-challenge-make-it-better",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/#extra-challenge-make-it-better"
  },"47": {
    "doc": "1: Reaction Game - Hardware and Code",
    "title": "1: Reaction Game - Hardware and Code",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/01-reaction-game-hw-code/",
    
    "relUrl": "/assignments/01-reaction-game-hw-code/"
  },"48": {
    "doc": "4: Game Controller Embodiment",
    "title": "Game Controller - Embodiment",
    "content": "This week we have the second embodiment assignment, this time for a game controller. When we think of a classic game controller, we often think of a joystick, and in more modern systems we almost always have a gamepad. However, the game controller is certainly not limited to these two options. Over the years, many different input devices have existed for home consoles. As early as the 1980s, the first Nintendo introduced the Light Gun to play Duck Hunt, and in 2006 they introduced the Nintendo Wii, which made use of player movement. | Home Game Controllers |   | . | | | . | Classic Joystick | Modern Gamepad | . | | . | Nintendo Light Gun | Nintendo Wii | . ##Japan’s Arcades . For truly creative alternative inputs, Japan’s arcade halls are a great place to look. There you can find everything from motorcycles you can sit on to full train simulators, dance machines, and the famous Cho Chabudai Gaeshi (Super Dinner Table Flipping), where the game controller is nothing more than a table that you can pound on after which you can flip the whole thing upside down to vent all your frustrations. | Japan’s Arcades |   | . | | | . | Motor Arcade | Train Opperator Simulator | . | | . | Dance A Highscore | Super Dinner Table Flipping | . ##Homemade Alternatives . We will keep things a bit more limited, but a simple input interface, if well designed and appropriately matched, can make a game much more enjoyable. For inspiration, you can find some alternative inputs here from the 2014 Alt.Cntrl.GDC event. | Alt.Ctrl.GDC |   | . | | | . | Missile Control Board | Guitar Padles as Input | . | | . | Caterpillar Simulator | Wooosh | . Finally, here are some input devices designed by students during a previous edition of this course. ",
    "url": "/Digital-Interfaces/test/assignments/04-game-controller-embodiment/#game-controller---embodiment",
    
    "relUrl": "/assignments/04-game-controller-embodiment/#game-controller---embodiment"
  },"49": {
    "doc": "4: Game Controller Embodiment",
    "title": "4: Game Controller Embodiment",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/04-game-controller-embodiment/",
    
    "relUrl": "/assignments/04-game-controller-embodiment/"
  },"50": {
    "doc": "5: Walkie-Talkie - Hardware and Code",
    "title": "Walkie-Talkie - Hardware and Code",
    "content": "This week you’ll build a small device that can send messages to someone else’s device. The message can be as simple as a single buzz, or something more structured—like a sequence in Morse code. We’ll use MQTT (a lightweight messaging protocol commonly used in Internet of Things projects) to send your message to a server. Once your message is published to the server, someone else can subscribe to your topic and receive it on their device. What you’ll do . | Publish a message from your device to an MQTT broker (server) | Subscribe to someone else’s topic to receive their messages | Design a message format (e.g., short buzz patterns or Morse-like timing) | . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie-hw-code/#walkie-talkie---hardware-and-code",
    
    "relUrl": "/assignments/05-walkie-talkie-hw-code/#walkie-talkie---hardware-and-code"
  },"51": {
    "doc": "5: Walkie-Talkie - Hardware and Code",
    "title": "Before we begin",
    "content": "For this week’s assignment, we prepared a lot of different code snippets to help you along. They are meant for you to use and modify for your specific design and device. Simple copy+pasting without a rough understanding of what you are copying will not work! . Although we will use a lot of code, you are not required to understand every little line, but rather analyse your needs and search for the specific code sample. As a prerequisite for this tutorial to work, make sure you followed and successfully completed Tutorial 4 of the Connected Interaction Kit website and connected your ItsyBitsy to the internet. After connecting to the internet the next step is to connect to the MQTT server. Get started . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie-hw-code/#before-we-begin",
    
    "relUrl": "/assignments/05-walkie-talkie-hw-code/#before-we-begin"
  },"52": {
    "doc": "5: Walkie-Talkie - Hardware and Code",
    "title": "Coding Instructions",
    "content": "In this assignment you will learn how to publish data to an MQTT topic and revise last week’s assignment on how to process received data. When connected to an MQTT server, we can not only listen to a topic (e.g. “perlin” and “iss/distance” from last week), but also send data to it! Sending data to the MQTT broker is called “publishing” and when doing so, all devices which are connected to the topic you’re sending information to will receive the data you send. If you didn’t complete last week’s assignment, you should make sure you have done the following things before starting with this assignment: . | Follow the tutorial on how to connect your board to TUD-facility wifi here. | Download the MQTT wrapper here and put it in your lib folder. | Create a settings.py file like the one shown in step 1 - 4: Data Embodiment and add the wifi credentials. | . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie-hw-code/#coding-instructions",
    
    "relUrl": "/assignments/05-walkie-talkie-hw-code/#coding-instructions"
  },"53": {
    "doc": "5: Walkie-Talkie - Hardware and Code",
    "title": "Coding Assignment",
    "content": "Your goal is to implement 2 buttons and an actuator of your choice (we recommend either a piezo buzzer or a vibration motor), in the following way: . | 1 button dedicated to opening the walkie-talkie channel | 1 button to send messages on the channel | 1 actuator that is triggered when a message is received | . Remember that walkie-talkies cannot receive messages while their channel is open. Just like last week, here below we present a template with almost everything you need to make your walkie-talkie work. Although, one crucial part is missing, the part inside the while loop, you should use the acting machine diagram below the code to make your walkie-talkie work. Happy coding! . Code template . | PicoExpander | BitsyExpander | . | ##--- Library Imports import time import digitalio import board import neopixel from MQTT import Create_MQTT from settings import settings ##--- Defining states state_idle = 0 state_receive = 1 state_channel_open = 2 state_transmit = 3 current_state = 0 # Define variable to save data received from the MQTT broker last_received_value = 0 ##--- Button variables open_channel_pin = board.GP6 open_channel_button = digitalio.DigitalInOut(open_channel_pin) open_channel_button.direction = digitalio.Direction.INPUT speak_channel_pin = board.GP8 speak_button = digitalio.DigitalInOut(speak_channel_pin) speak_button.direction = digitalio.Direction.INPUT ##-- Led variables pin_leds = board.GP10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_blue = (0, 0, 255, 0) led_green = (0, 255, 0, 0) led_white = (0, 0, 0, 255) def set_led_color(color): global leds leds.fill(color) leds.show() ##--- Actuator variables actuator = digitalio.DigitalInOut(board.GP12) actuator.direction = digitalio.Direction.OUTPUT # For more information on how to use PWM check this link: # https://id-studiolab.github.io/Connected-Interaction-Kit/components/piezo-buzzer/piezo-buzzer.html#define-a-tone-using-pulse-width-modulation-pwm #actuator = pwmio.PWMOut(board.GP14, variable_frequency=True) ##--- MQTT configuration # Define variable to save data received from the MQTT broker last_received_value = 0 device_has_received_new_value = False # Method used when the board receives a message from the MQTT server. def handle_message(client, topic, msg): global last_received_value global device_has_received_new_value # Assign message received to last_received variable last_received_value = msg device_has_received_new_value = True # You can find the client Id in the settings.py this is used to identify the board client_id = settings[\"mqtt_clientid\"] # Create a mqtt connection based on the settings file. mqtt_client = Create_MQTT(client_id, handle_message) # &lt;--------------------------------------------&gt; # -- DEFINE YOUR SPEAK AND LISTEN TOPIC HERE -- # VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV # Here you should select the topic of the person you want to talk to. # Write the topic you want to send messages to. mqtt_speak_topic = \"Studio05-Lisa-WalkieTalkie\" # You should set as \"listen_topic\" their \"speak_topic\" and vice-versa mqtt_listen_topic = \"Studio05-Bram-WalkieTalkie\" # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ # &lt;--------------------------------------------&gt; # Listen for messages on the topic specified above mqtt_client.subscribe(mqtt_listen_topic) ##--- Main loop while True: try: mqtt_client.loop(0.1) except (ValueError, RuntimeError) as e: print(\"Failed to get data, retrying\\n\", e) mqtt_client.reconnect() continue # --------------------------------------------- # ^ DO NOT CHANGE ANYTHING ABOVE THIS POINT ^ | # --------------------------------------------- message = \"ping\" # Use this method to publish messages on a topic: # mqtt_client.publish(mqtt_speak_topic, message) # ----------------------------------------------------------------| # | # Use the Acting Machine Diagram to program your solution here | # | # Hint: Use of the \"device_has_received_new_value\" variable | # Use the open_channel_button and speak_button variables | # Use the led variable (copied from the reation game code) | # ----------------------------------------------------------------| # ---------------------------------------------- # v DO NOT CHANGE ANYTHING BELOW THIS POINT v | # ---------------------------------------------- device_has_received_new_value = False time.sleep(0.1) . | ##--- Library Imports import time import digitalio import board import neopixel from MQTT import Create_MQTT from settings import settings ##--- Defining states state_idle = 0 state_receive = 1 state_channel_open = 2 state_transmit = 3 current_state = 0 # Define variable to save data received from the MQTT broker last_received_value = 0 ##--- Button variables open_channel_pin = board.D13 open_channel_button = digitalio.DigitalInOut(open_channel_pin) open_channel_button.direction = digitalio.Direction.INPUT speak_channel_pin = board.D7 speak_button = digitalio.DigitalInOut(speak_channel_pin) speak_button.direction = digitalio.Direction.INPUT ##-- Led variables pin_leds = board.D3 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_blue = (0, 0, 255, 0) led_green = (0, 255, 0, 0) led_white = (0, 0, 0, 255) def set_led_color(color): global leds leds.fill(color) leds.show() ##--- Actuator variables actuator = digitalio.DigitalInOut(board.D4) actuator.direction = digitalio.Direction.OUTPUT # For more information on how to use PWM check this link: # https://id-studiolab.github.io/Connected-Interaction-Kit/components/piezo-buzzer/piezo-buzzer.html#define-a-tone-using-pulse-width-modulation-pwm #actuator = pwmio.PWMOut(board.D4, variable_frequency=True) ##--- MQTT configuration # Define variable to save data received from the MQTT broker last_received_value = 0 device_has_received_new_value = False # Method used when the board receives a message from the MQTT server. def handle_message(client, topic, msg): global last_received_value global device_has_received_new_value # Assign message received to last_received variable last_received_value = msg device_has_received_new_value = True # You can find the client Id in the settings.py this is used to identify the board client_id = settings[\"mqtt_clientid\"] # Create a mqtt connection based on the settings file. mqtt_client = Create_MQTT(client_id, handle_message) # &lt;--------------------------------------------&gt; # -- DEFINE YOUR SPEAK AND LISTEN TOPIC HERE -- # VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV # Here you should select the topic of the person you want to talk to. # Write the topic you want to send messages to. mqtt_speak_topic = \"Studio05-Lisa-WalkieTalkie\" # You should set as \"listen_topic\" their \"speak_topic\" and vice-versa mqtt_listen_topic = \"Studio05-Bram-WalkieTalkie\" # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ # &lt;--------------------------------------------&gt; # Listen for messages on the topic specified above mqtt_client.subscribe(mqtt_listen_topic) ##--- Main loop while True: try: mqtt_client.loop(0.1) except (ValueError, RuntimeError) as e: print(\"Failed to get data, retrying\\n\", e) mqtt_client.reconnect() continue # --------------------------------------------- # ^ DO NOT CHANGE ANYTHING ABOVE THIS POINT ^ | # --------------------------------------------- message = \"ping\" # Use this method to publish messages on a topic: # mqtt_client.publish(mqtt_speak_topic, message) # ----------------------------------------------------------------| # | # Use the Acting Machine Diagram to program your solution here | # | # Hint: Use of the \"device_has_received_new_value\" variable | # Use the open_channel_button and speak_button variables | # Use the led variable (copied from the reation game code) | # ----------------------------------------------------------------| # ---------------------------------------------- # v DO NOT CHANGE ANYTHING BELOW THIS POINT v | # ---------------------------------------------- device_has_received_new_value = False time.sleep(0.1) . | . | Acting Machine Diagram | . | | . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie-hw-code/#coding-assignment",
    
    "relUrl": "/assignments/05-walkie-talkie-hw-code/#coding-assignment"
  },"54": {
    "doc": "5: Walkie-Talkie - Hardware and Code",
    "title": "Understanding Speak and Listen Topics",
    "content": "In the code, you’ll find two variables called mqtt_speak_topic and mqtt_listen_topic. You can use them to establish communication between walkie-talkies. Speak Topic = where you send messages Listen Topic = where you receive messages . For two devices to communicate: . | Your speak topic must be your partner’s listen topic | Your listen topic must be your partner’s speak topic | . Example: . Your Device: - Speak Topic: \"Studio05-YourName-WalkieTalkie\" - Listen Topic: \"Studio05-PartnerName-WalkieTalkie\" Partner's Device: - Speak Topic: \"Studio05-PartnerName-WalkieTalkie\" - Listen Topic: \"Studio05-YourName-WalkieTalkie\" . Note: Topics must match exactly, including capitalization! . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie-hw-code/#understanding-speak-and-listen-topics",
    
    "relUrl": "/assignments/05-walkie-talkie-hw-code/#understanding-speak-and-listen-topics"
  },"55": {
    "doc": "5: Walkie-Talkie - Hardware and Code",
    "title": "Extra Challenge: Interpret received messages",
    "content": "In the current assignment, your walkie-talkie sends a fixed message (“ping”) each time you press the button. But real communication isn’t just about sending the same thing over and over; messages can carry different meanings! . For this challenge, modify your code so that different messages can be sent instead of always sending “ping”. Think about the different ways in which you could send different messages, for example, assign two buttons or create a switch to select messages before sending. When receiving messages, be sure that your walkie-talkie also interprets incoming messages and responds differently based on their content. Think about how this could enhance the interaction, different messages could trigger different responses from the actuator, maybe also triggering different actuators. Push yourself to explore how MQTT can be used for more dynamic communication! . Here below we provide a more advanced acting machine digram to help you create your improved walkie-talkie . | Acting Machine Diagram | . | | . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie-hw-code/#extra-challenge-interpret-received-messages",
    
    "relUrl": "/assignments/05-walkie-talkie-hw-code/#extra-challenge-interpret-received-messages"
  },"56": {
    "doc": "5: Walkie-Talkie - Hardware and Code",
    "title": "5: Walkie-Talkie - Hardware and Code",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie-hw-code/",
    
    "relUrl": "/assignments/05-walkie-talkie-hw-code/"
  },"57": {
    "doc": "3: Game Controller - Hardware and Code",
    "title": "Game Controller - Hardware and Code",
    "content": "In this week’s assignment we are going to build and embody a physical controller to control a game on our screen. ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/#game-controller---hardware-and-code",
    
    "relUrl": "/assignments/03-game-controller-hw-code/#game-controller---hardware-and-code"
  },"58": {
    "doc": "3: Game Controller - Hardware and Code",
    "title": "Coding Instructions",
    "content": "In this assignment, you’ll learn how to use the usb_hid library to simulate keyboard or mouse inputs with your microcontroller. Remember that when working with keyboards, it’s important to understand how keys are mapped to characters in a specific layout, and that you have the correct layout configured in your code. Pressing a key once typically produces a single character on the screen. However, holding a key down can result in multiple repeated characters. The usb_hid library lets you simulate these behaviors with commands like keyboard.press(key) to simulate a key press and keyboard.release_all() to release all pressed keys. In this assignment you’ll also explore Python basics, such as variables, loops (while), conditional statements (if, elif, else), and working with functions. By integrating these concepts with the usb_hid library, you’ll gain the skills to create interactive devices that can simulate keyboard or mouse actions dynamically. ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/#coding-instructions",
    
    "relUrl": "/assignments/03-game-controller-hw-code/#coding-instructions"
  },"59": {
    "doc": "3: Game Controller - Hardware and Code",
    "title": "Possible games you can play",
    "content": "These are just some examples of games you can play, and there are many more online (or to download). Your chosen embodiment should fit the game! . | Flappy Bird | Drift Boss | Pong Game | Crazy Flips | Canabalt | Any other game that you find fun… | . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/#possible-games-you-can-play",
    
    "relUrl": "/assignments/03-game-controller-hw-code/#possible-games-you-can-play"
  },"60": {
    "doc": "3: Game Controller - Hardware and Code",
    "title": "Safe mode",
    "content": "Especially when your ItsyBitsy is sending (wrong) keyboard inputs to your laptop, it can be useful to be able to stop the code from running, while still editing the code. By pressing the reset button right after start-up, while the LED is blinking yellow, the ItsyBitsy goes into Safe mode where it will not execute any of your code.py. You can do this right after plugging it in to your computer, or by pressing the reset button, waiting for the yellow lights, and pressing reset again. This allows you to fix the code without it interferring with your inputs. It will also disable auto-reload, so to start running your code again, you have to press the reset button once more. ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/#safe-mode",
    
    "relUrl": "/assignments/03-game-controller-hw-code/#safe-mode"
  },"61": {
    "doc": "3: Game Controller - Hardware and Code",
    "title": "Coding Assignment",
    "content": "You will see that different games need different inputs. Here below we present a template with almost everything you need to make your game controller work. Although, one crucial part is missing, the part inside the while loop. Your assignment is to use the template code and the acting machine diagram here below to create a working controller. Before starting, if it’s your first time coding or has been a while since the last time, we created this page that quickly introduces you to some key coding elements: Coding instructions . | Acting Machine Diagram | . | | . Code template . ##--- Library Imports import time import board import digitalio # We want to emulate a keyboard interface # To do so we use the usb_hid (Human-interface device) library to send commands to our computer import usb_hid from adafruit_hid.keyboard import Keyboard from adafruit_hid.keyboard_layout_us import KeyboardLayoutUS from adafruit_hid.keycode import Keycode ##--- Defining states state_wait = 0 state_button_is_pressed = 1 current_state = 0 ##--- Keyboard variables # Define a new keyboard and set the layout to US (mostly same as the Dutch layout) keyboard = Keyboard(usb_hid.devices) keyboard_layout = KeyboardLayoutUS(keyboard) # We want to send the SPACE key when the button is pressed # For other keys search online \"Circuit Python Keycode\" key = Keycode.SPACE ##--- Button variables ## Define a new button variable and assign it to port D13 of our board button = digitalio.DigitalInOut(board.D6) ## Define the button as an input component button.direction = digitalio.Direction.INPUT ##--- Main loop # Sleep for a bit to allow the host operating system to configure the new USB device time.sleep(1) while True: # -------------------------------------------------------------| # | # Use the Acting Machine Diagram to program your solution here | # | # -------------------------------------------------------------| # Sleep for a bit to make the keypress events occur at a human timescale # Skilled gamers can do ~7 button presses per second (says ChatGPT) so # we sample with twice that frequency to adher to the Nyquist rate. time.sleep(0.07) . If you are struggling with the assignment we provide the solution here below. Attention: Keep in mind that from next week on you won’t find a solution to the assignments, so you should take this opportunity to become familiar with programming concepts and try hard to make the code work. Jumping straight to the solution might seem tempting, but it’s important to work through the assignment on your own first. By skipping ahead, you’ll miss out on learning critical concepts and skills that are essential for the next stages of the course. Code solution . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/#coding-assignment",
    
    "relUrl": "/assignments/03-game-controller-hw-code/#coding-assignment"
  },"62": {
    "doc": "3: Game Controller - Hardware and Code",
    "title": "Extra Challenge 1: Control your mouse!",
    "content": "In this week’s extra challenge you’ll explore how to use the usb_hid library to control mouse movements and simulate clicks. Here we propose a brief introduction on how to use the mouse functions from the usb_hid library: . Key Functions for Mouse Control . Mouse Clicks . | Use mouse.press(button) to simulate pressing a mouse button (e.g., Mouse.LEFT_BUTTON for the left button or Mouse.RIGHT_BUTTON for the right button). | Use mouse.release(button) to simulate releasing the button. | To ensure all buttons are released, use mouse.release_all(). | . Moving the Mouse . | Use mouse.move(x=amount, y=amount) to move the mouse pointer: . | The x parameter controls horizontal movement (positive for right, negative for left). | The y parameter controls vertical movement (positive for down, negative for up). | . | . Scrolling . | Use mouse.move(wheel=amount) to simulate scrolling the mouse wheel. Positive values scroll up, and negative values scroll down. | . Your Challenge . The previous section shows how to handle button inputs and control the mouse. Use it to try and implement your own logic to play different games from the ones listed. Have fun with this challenge, and don’t hesitate to test out creative ideas! The more you experiment, the more you’ll understand how to bring your prototypes to life. If you’re lost check the state diagram below for some inspiration on how to structure your code! . | Acting Machine Diagram | . | | . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/#extra-challenge-1-control-your-mouse",
    
    "relUrl": "/assignments/03-game-controller-hw-code/#extra-challenge-1-control-your-mouse"
  },"63": {
    "doc": "3: Game Controller - Hardware and Code",
    "title": "Extra Challenge 2: Use an IMU sensor as input!",
    "content": "This IMU (Inertial Measurement Unit) can measure both linear acceleration and angular velocity. It also senses gravity, which makes it possible to determine the device’s orientation relative to the world. Unlike simple digital sensors that only return a 0 or 1, the IMU outputs continuous (“analog”) values. Acceleration is measured in a range of −16 g to +16 g, and angular velocity in a range of −2000 dps to +2000 dps. Because it can track movement and orientation, this type of sensor enables a wide range of possibilities for creative game input devices. | IMU Sensor | . | | . Your Challenge . In the code example below, acceleration is mapped to the mouse pointer. The implementation is minimal but functional. How could you adapt this code to create a fun gameplay experience? Think about issues as smoothing, velocity mapping and input frequency and of course there is always the possibily to map the input on to different outputs (like key presses) or to use the angular velocity as an input. Just play around and see what gives a fun result. Code template . ##--- library imports import time import board import busio import digitalio import usb_hid from adafruit_hid.mouse import Mouse from adafruit_lsm6ds.lsm6ds3trc import LSM6DS3TRC ##--- object declarations mouse = Mouse(usb_hid.devices) imu_i2c = busio.I2C(board.SCL, board.SDA) sensor = LSM6DS3TRC(imu_i2c, address=0x6b) while True: accel_x, accel_y, accel_z = sensor.acceleration print(f\"Acceleration: X:{accel_x:.2f}, Y: {accel_y:.2f}, Z: {accel_z:.2f} m/s^2\") gyro_x, gyro_y, gyro_z = sensor.gyro print(f\"Gyro X:{gyro_x:.2f}, Y: {gyro_y:.2f}, Z: {gyro_z:.2f} radians/s\") mouse.move(int(accel_x),int(accel_y)) time.sleep(0.2) . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/#extra-challenge-2-use-an-imu-sensor-as-input",
    
    "relUrl": "/assignments/03-game-controller-hw-code/#extra-challenge-2-use-an-imu-sensor-as-input"
  },"64": {
    "doc": "3: Game Controller - Hardware and Code",
    "title": "3: Game Controller - Hardware and Code",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller-hw-code/",
    
    "relUrl": "/assignments/03-game-controller-hw-code/"
  },"65": {
    "doc": "2: Reaction Game - Embodiment",
    "title": "Reaction Game - Embodiment",
    "content": "After last week’s assignment, where we built the hardware and wrote the code, this week we will work on the embodiment of the reaction game. Materials are available in the studio, but you are of course welcome to use materials you bring yourself. The standard game consists of two buttons and one LED, but there are countless possible variations that can strongly influence the gameplay. This week the focus is mainly on the embodiment, but small adjustments to the code can always be made if they support your design and improve the gameplay. ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game-embodiment/#reaction-game---embodiment",
    
    "relUrl": "/assignments/02-reaction-game-embodiment/#reaction-game---embodiment"
  },"66": {
    "doc": "2: Reaction Game - Embodiment",
    "title": "Commercial Reaction Games",
    "content": "| Catching Sticks Game | Whac-A-Mole | . | | | . |   |   | . ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game-embodiment/#commercial-reaction-games",
    
    "relUrl": "/assignments/02-reaction-game-embodiment/#commercial-reaction-games"
  },"67": {
    "doc": "2: Reaction Game - Embodiment",
    "title": "Inspiration from Previous Years",
    "content": "| Minifigs as Buttons | . | | . | Extended Levers | . | | . | ??? | . | | . | Gun Duel | . | | . ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game-embodiment/#inspiration-from-previous-years",
    
    "relUrl": "/assignments/02-reaction-game-embodiment/#inspiration-from-previous-years"
  },"68": {
    "doc": "2: Reaction Game - Embodiment",
    "title": "2: Reaction Game - Embodiment",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game-embodiment/",
    
    "relUrl": "/assignments/02-reaction-game-embodiment/"
  },"69": {
    "doc": "Assignments",
    "title": "Assignments",
    "content": "Here you will find necessary code examples and documentations for assignments of Digital Interfaces. ",
    "url": "/Digital-Interfaces/test/assignments/",
    
    "relUrl": "/assignments/"
  },"70": {
    "doc": "Home",
    "title": "Digital Interfaces",
    "content": " ",
    "url": "/Digital-Interfaces/test/#digital-interfaces",
    
    "relUrl": "/#digital-interfaces"
  },"71": {
    "doc": "Home",
    "title": "Assignments",
    "content": "1: Reaction Game - Hardware and Code . 2: Reaction Game - Embodiment . 3: Game Controller - Hardware and Code . 4: Game Controller - Embodiment . 5: Walkie-Talkie - Hardware and Code . 6: Walkie-Talkie - Embodiment . 7+8: Animistic design . ",
    "url": "/Digital-Interfaces/test/#assignments",
    
    "relUrl": "/#assignments"
  },"72": {
    "doc": "Home",
    "title": "Tutorials",
    "content": "Building a Pomodoro timer . ",
    "url": "/Digital-Interfaces/test/#tutorials",
    
    "relUrl": "/#tutorials"
  },"73": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/Digital-Interfaces/test/",
    
    "relUrl": "/"
  },"74": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Triggering different sequences based on context or interaction",
    "content": "How could we trigger different sequences based on user or context interaction? In this example, we will create a little ItsyCreature that sleeps peacefully until disturbed – in that case it wakes up and gets angry at the disturbance! . Connect the Chainable LED to pin D13, the Servo Motor to pin D2 and the Touch Sensor to D3. By default, the creature will “sleep” in peace, but when touched get angry until the sensor is released again. | PicoExpander | BitsyExpander | . | ##--- Library Imports import time import board import neopixel import pwmio import digitalio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup # Add a touch sensor touch = digitalio.DigitalInOut(board.GP8) touch.direction = digitalio.Direction.INPUT pin_leds = board.GP10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) pwm = pwmio.PWMOut(board.GP6, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence_sleep = [ (80, 3, 80, \"QuadEaseIn\"), (80, 2, 1, \"LinearInOut\"), (0, 3, 80, \"QuadEaseInOut\"), (0, 2, 1, \"LinearInOut\") ] led_sequence_angry = [ (MAX_LED, 0.01, 1, \"QuadEaseInOut\"), (MIN_LED, 0.01, 1, \"QuadEaseInOut\") ] servo_sequence_sleep = [ (0, 1.0, 1, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (0, 10.0, 11, \"LinearInOut\") ] servo_sequence_angry = [ (10, 0.01, 1, \"LinearInOut\"), (MIN_SERVO, 0.01, 1, \"LinearInOut\") ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.show() ##--- Main loop while True: if touch.value == False: print(\"sleeping 😴\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_sleep, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED White led_value = int(position_led) leds.fill((0, 0, 0, led_value)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_sleep, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo elif touch.value == True: print(\"angry!!! 😡\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_angry, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED Red led_value = int(position_led) leds.fill((led_value, 0, 0)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_angry, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo time.sleep(0.05) . | ##--- Library Imports import time import board import neopixel import pwmio import digitalio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup # Add a touch sensor touch = digitalio.DigitalInOut(board.D3) touch.direction = digitalio.Direction.INPUT pin_leds = board.D13 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence_sleep = [ (80, 3, 80, \"QuadEaseIn\"), (80, 2, 1, \"LinearInOut\"), (0, 3, 80, \"QuadEaseInOut\"), (0, 2, 1, \"LinearInOut\") ] led_sequence_angry = [ (MAX_LED, 0.01, 1, \"QuadEaseInOut\"), (MIN_LED, 0.01, 1, \"QuadEaseInOut\") ] servo_sequence_sleep = [ (0, 1.0, 1, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (0, 10.0, 11, \"LinearInOut\") ] servo_sequence_angry = [ (10, 0.01, 1, \"LinearInOut\"), (MIN_SERVO, 0.01, 1, \"LinearInOut\") ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.show() ##--- Main loop while True: if touch.value == False: print(\"sleeping 😴\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_sleep, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED White led_value = int(position_led) leds.fill((0, 0, 0, led_value)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_sleep, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo elif touch.value == True: print(\"angry!!! 😡\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_angry, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED Red led_value = int(position_led) leds.fill((led_value, 0, 0)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_angry, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo time.sleep(0.05) . | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/trigger-different-sequences/neopixel.html#triggering-different-sequences-based-on-context-or-interaction",
    
    "relUrl": "/assignments/07+08-animistic-design/trigger-different-sequences/neopixel.html#triggering-different-sequences-based-on-context-or-interaction"
  },"75": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Chainable LED ChaiNEO",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/trigger-different-sequences/neopixel.html",
    
    "relUrl": "/assignments/07+08-animistic-design/trigger-different-sequences/neopixel.html"
  },"76": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Fading and blinking a Chainable LED",
    "content": "This example used the Chainable LED of the Connected Interaction Kit, connected to D13 of the Expander Board. | PicoExpander | BitsyExpander | . | ##--- Library Imports import time import board import neopixel from varspeed import Vspeed ##--- VarSpeed Variables MIN = 0.0 # The minimum possible value of our component MAX = 1.0 # The maximum possible value of our component vs = Vspeed(init_position=MIN, result=\"float\") # init_position = initial start position // result = float, int vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # make the output of the function be within the bounds set ##--- Hardware Setup pin_leds = board.GP6 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, brightness=0.5, auto_write=False, pixel_order=neopixel.GRBW) ##--- Custom Movement Sequence # This is where we can define the brightness of our LED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] # Define what should happen when we get to the end of our sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times leds.fill((0, 255, 0)) # Color the LED green leds.show() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position, running, changed = vs.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed: print( f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') leds.brightness = position leds.show() . | ##--- Library Imports import time import board import neopixel from varspeed import Vspeed ##--- VarSpeed Variables MIN = 0.0 # The minimum possible value of our component MAX = 1.0 # The maximum possible value of our component vs = Vspeed(init_position=MIN, result=\"float\") # init_position = initial start position // result = float, int vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # make the output of the function be within the bounds set ##--- Hardware Setup pin_leds = board.D13 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, brightness=0.5, auto_write=False, pixel_order=neopixel.GRBW) ##--- Custom Movement Sequence # This is where we can define the brightness of our LED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] # Define what should happen when we get to the end of our sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times leds.fill((0, 255, 0)) # Color the LED green leds.show() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position, running, changed = vs.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed: print( f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') leds.brightness = position leds.show() . | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/neopixel.html#fading-and-blinking-a-chainable-led",
    
    "relUrl": "/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/neopixel.html#fading-and-blinking-a-chainable-led"
  },"77": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Chainable LED ChaiNEO",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/neopixel.html",
    
    "relUrl": "/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/neopixel.html"
  },"78": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Running two sequences simultaneously",
    "content": "When we want to run two sequences at the same time, for example to control a servo and an LED, we basically have to double everything from the individual sequence. In this example, we will let the Chainable LED on pin D13 blink, while we wiggle the servo motor connected to D2 . | PicoExpander | BitsyExpander | . | ##--- Library Imports import time import board import neopixel import pwmio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup pin_leds = board.GP6 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) pwm = pwmio.PWMOut(board.GP8, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX_LED, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN_LED, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Translates to: Go to value 180 within 5 seconds and 100 steps, and use a linear easing function (0, 2.0, 5, \"QuadEaseOut\"), # Translates to: Go to value 0 within 2 seconds and 5 steps, and use a QuadEaseOut easing function (90, 2.0, 10, \"SineEaseInOut\") # Translates to: Go to value 90 within 2 seconds and 10 steps, and use a SineEaseInOut easing function ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.show() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') leds.fill((int(position_led), 0, 0)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo . | ##--- Library Imports import time import board import neopixel import pwmio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup pin_leds = board.D13 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX_LED, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN_LED, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Translates to: Go to value 180 within 5 seconds and 100 steps, and use a linear easing function (0, 2.0, 5, \"QuadEaseOut\"), # Translates to: Go to value 0 within 2 seconds and 5 steps, and use a QuadEaseOut easing function (90, 2.0, 10, \"SineEaseInOut\") # Translates to: Go to value 90 within 2 seconds and 10 steps, and use a SineEaseInOut easing function ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.show() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') leds.fill((int(position_led), 0, 0)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo . | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/running-two-sequences/neopixel.html#running-two-sequences-simultaneously",
    
    "relUrl": "/assignments/07+08-animistic-design/running-two-sequences/neopixel.html#running-two-sequences-simultaneously"
  },"79": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Chainable LED ChaiNEO",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/running-two-sequences/neopixel.html",
    
    "relUrl": "/assignments/07+08-animistic-design/running-two-sequences/neopixel.html"
  },"80": {
    "doc": "Chainable LED P9813",
    "title": "Triggering different sequences based on context or interaction",
    "content": "How could we trigger different sequences based on user or context interaction? In this example, we will create a little ItsyCreature that sleeps peacefully until disturbed – in that case it wakes up and gets angry at the disturbance! . Connect the Chainable LED to pin D13, the Servo Motor to pin D2 and the Touch Sensor to D3. By default, the creature will “sleep” in peace, but when touched get angry until the sensor is released again. ##--- Library Imports import time import board import p9813 import pwmio import digitalio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup # Add a touch sensor touch = digitalio.DigitalInOut(board.D3) touch.direction = digitalio.Direction.INPUT pin_clk = board.D13 pin_data = board.D10 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence_sleep = [ (80, 3, 80, \"QuadEaseIn\"), (80, 2, 1, \"LinearInOut\"), (0, 3, 80, \"QuadEaseInOut\"), (0, 2, 1, \"LinearInOut\") ] led_sequence_angry = [ (MAX_LED, 0.01, 1, \"QuadEaseInOut\"), (MIN_LED, 0.01, 1, \"QuadEaseInOut\") ] servo_sequence_sleep = [ (0, 1.0, 1, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (0, 10.0, 11, \"LinearInOut\") ] servo_sequence_angry = [ (10, 0.01, 1, \"LinearInOut\"), (MIN_SERVO, 0.01, 1, \"LinearInOut\") ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.write() ##--- Main loop while True: if touch.value == False: print(\"sleeping 😴\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_sleep, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED White led_value = int(position_led) leds.fill((led_value, led_value, led_value)) leds.write() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_sleep, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo elif touch.value == True: print(\"angry!!! 😡\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_angry, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED Red led_value = int(position_led) leds.fill((led_value, 0, 0)) leds.write() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_angry, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo time.sleep(0.05) . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/trigger-different-sequences/p9813.html#triggering-different-sequences-based-on-context-or-interaction",
    
    "relUrl": "/assignments/07+08-animistic-design/trigger-different-sequences/p9813.html#triggering-different-sequences-based-on-context-or-interaction"
  },"81": {
    "doc": "Chainable LED P9813",
    "title": "Chainable LED P9813",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/trigger-different-sequences/p9813.html",
    
    "relUrl": "/assignments/07+08-animistic-design/trigger-different-sequences/p9813.html"
  },"82": {
    "doc": "Chainable LED P9813",
    "title": "Fading and blinking a Chainable LED (Groove)",
    "content": "This example used the Chainable LED of the Connected Interaction Kit, connected with the IN to D13 and the OUT to D10 of the Expander Board . ##--- Library Imports import time import board import p9813 from varspeed import Vspeed ##--- VarSpeed Variables MIN = 0 # The minimum possible value of our component MAX = 255 # The maximum possible value of our component vs = Vspeed(init_position=MIN, result=\"int\") # init_position = initial start position // result = float, int vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # make the output of the function be within the bounds set ##--- Hardware Setup pin_clk = board.D13 pin_data = board.D10 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] # Define what should happen when we get to the end of our sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times leds.fill((0, 0, 0)) leds.write() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position, running, changed = vs.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed: print( f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') leds.fill((int(position), 0, 0)) leds.write() . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/p9813.html#fading-and-blinking-a-chainable-led-groove",
    
    "relUrl": "/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/p9813.html#fading-and-blinking-a-chainable-led-groove"
  },"83": {
    "doc": "Chainable LED P9813",
    "title": "Chainable LED P9813",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/p9813.html",
    
    "relUrl": "/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/p9813.html"
  },"84": {
    "doc": "Chainable LED P9813",
    "title": "Running two sequences simultaneously",
    "content": "When we want to run two sequences at the same time, for example to control a servo and an LED, we basically have to double everything from the individual sequence. In this example, we will let the Chainable LED on pin D13 blink, while we wiggle the servo motor connected to D2 . ##--- Library Imports import time import board import p9813 import pwmio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup pin_clk = board.D13 pin_data = board.D10 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX_LED, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN_LED, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Translates to: Go to value 180 within 5 seconds and 100 steps, and use a linear easing function (0, 2.0, 5, \"QuadEaseOut\"), # Translates to: Go to value 0 within 2 seconds and 5 steps, and use a QuadEaseOut easing function (90, 2.0, 10, \"SineEaseInOut\") # Translates to: Go to value 90 within 2 seconds and 10 steps, and use a SineEaseInOut easing function ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.write() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') leds.fill((int(position_led), 0, 0)) leds.write() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/running-two-sequences/p9813.html#running-two-sequences-simultaneously",
    
    "relUrl": "/assignments/07+08-animistic-design/running-two-sequences/p9813.html#running-two-sequences-simultaneously"
  },"85": {
    "doc": "Chainable LED P9813",
    "title": "Chainable LED P9813",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/running-two-sequences/p9813.html",
    
    "relUrl": "/assignments/07+08-animistic-design/running-two-sequences/p9813.html"
  },"86": {
    "doc": "Running two sequences simultaneously",
    "title": "Running two sequences simultaneously",
    "content": "When we want to run two sequences at the same time, for example to control a servo and an LED, we basically have to double everything from the individual sequence. In this example, we will let the Chainable LED on pin D6 blink, while we wiggle the servo motor connected to D8 . ##--- Library Imports import time import board import neopixel import pwmio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup pin_leds = board.D6 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) pwm = pwmio.PWMOut(board.D8, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX_LED, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN_LED, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Translates to: Go to value 180 within 5 seconds and 100 steps, and use a linear easing function (0, 2.0, 5, \"QuadEaseOut\"), # Translates to: Go to value 0 within 2 seconds and 5 steps, and use a QuadEaseOut easing function (90, 2.0, 10, \"SineEaseInOut\") # Translates to: Go to value 90 within 2 seconds and 10 steps, and use a SineEaseInOut easing function ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.show() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') leds.fill((int(position_led), 0, 0)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/running-two-sequences-index.html",
    
    "relUrl": "/assignments/07+08-animistic-design/running-two-sequences-index.html"
  },"87": {
    "doc": "Step 1: Code until now",
    "title": "Without Statemachine",
    "content": "import time import board import analogio import digitalio import neopixel # Register sensors sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() while True: if sound_sensor.value &gt; 30000: leds.fill(color_on) leds.show() time.sleep(1) leds.fill(color_off) leds.show() . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-1-code.html#without-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-1-code.html#without-statemachine"
  },"88": {
    "doc": "Step 1: Code until now",
    "title": "With statemachine",
    "content": "import time import board import analogio import digitalio import neopixel # States state_on = 0 state_off = 1 current_state = 0 # Register sensors sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() while True: if current_state == state_off: # make sure the LED is off leds.fill(color_off) leds.show() # check if we should turn on if sound_sensor.value &gt; 30000: current_state = state_on elif current_state == state_on: leds.fill(color_on) leds.show() time.sleep(1) current_state = state_off . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-1-code.html#with-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-1-code.html#with-statemachine"
  },"89": {
    "doc": "Step 1: Code until now",
    "title": "Step 1: Code until now",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-1-code.html",
    
    "relUrl": "/tutorials/coding-challenge/step-1-code.html"
  },"90": {
    "doc": "Setting up MQTT on your ItsyBitsy",
    "title": "Setting up MQTT on your ItsyBitsy",
    "content": "After successfully completing Tutorial 4 and connected your ItsyBitsy to the Internet, follow the steps below to establish a basic MQTT connection with our MQTT server. | Extend your settings.py file and add the entries for the MQTT broker (the server we connect to), be sure to set your username in the parameter called mqtt_clientid (please construct it as Studio[your studio]_YourName). Save the file afterwards. settings = { \"ssid\" : \"TUD-facility\", # The wifi we connect to \"password\" : \"replace-with-your-iPSK-String\", # Our personal password to connect to Wifi \"mqtt_broker\" : \"ide-education.cloud.shiftr.io\", # The MQTT server we connect to \"mqtt_user\" : \"ide-education\", # The username for connecting to the server \"mqtt_password\" : \"Sy0L85iwSSgc1P7E\", # The password for connecting to the server \"mqtt_clientid\": \"Studio5_Caspar\", # The device name we present to the server when connecting } . | We’ve created a library that helps your microcontroller connect to WiFi, connect to an MQTT broker and takes care of the details of receiving and publishing messages. Download the library using the button below, unzip it, and place the file named MQTT.py directly in the lib folder on your microcontroller. Don’t put the entire folder in lib - just the MQTT.py file itself. | . Download MQTT wrapper . If you followed the tutorial to connect to the wifi replace that code with the one below, otherwise create a new code.py copy the following code. TUD-facility can sometimes be unreliable, you can choose to use your phone hotspot instead. To do so change settings.py and set the ssid to the name of your hotspot and the password to your password. If you’re using an iPhone it is necessary that you turn on the Maximize-Compatibility option in your hotspot settings. ##--- Library Imports import time import digitalio import board from MQTT import Create_MQTT from settings import settings ##--- Defining states state_idle = 0 state_received_value = 1 current_state = 0 # Define variable to save data received from the MQTT broker last_received_value = 0 device_has_received_new_value = False ##--- MQTT Setup # Method used when the board receives # a message from the MQTT server. def handle_message(client, topic, msg): global last_received_value global device_has_received_new_value # Assign message received to last_received variable last_received_value = msg device_has_received_new_value = True # You can find the client Id in the settings.py this is used to identify the board client_id = settings[\"mqtt_clientid\"] # &lt;--------------------------------------------&gt; # -- CHOOSE YOUR LISTEN TOPIC HERE -- # VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV # Here you can choose what topic you want to subscribe to. The default is Perlin Noise. # Make sure there is only one topic active at any given time (and otherwise add a # before the one you do not want to use anymore) MQTT_topic = \"perlin\" #MQTT_topic = \"iss/distance\" #MQTT_topic = \"iss/location\" #MQTT_topic = \"coffee-waiting-line\" #MQTT_topic = \"windspeed\" #MQTT_topic = \"temperature\" # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ # &lt;--------------------------------------------&gt; # Create a mqtt connection based on the settings file. mqtt_client = Create_MQTT(client_id, handle_message) # Listen for messages on the topic specified above mqtt_client.subscribe(MQTT_topic) # --- Main loop while True: # This try / except loop is used to continuously get new data from MQTT, and reset if anything goes wrong try: mqtt_client.loop(0.1) except (ValueError, RuntimeError) as e: print(\"Failed to get data, retrying\\n\", e) mqtt_client.reconnect() continue # --------------------------------------------- # ^ DO NOT CHANGE ANYTHING ABOVE THIS POINT ^ | # --------------------------------------------- # ----------------------------------------------------------------| # | # Use the Acting Machine Diagram to program your solution here | # | # ----------------------------------------------------------------| # Example to print the received data - you may want to use this for your code solution if device_has_received_new_value == True: print(last_received_value) # ---------------------------------------------- # v DO NOT CHANGE ANYTHING BELOW THIS POINT v | # ---------------------------------------------- device_has_received_new_value = False time.sleep(0.01) . If you’re trying to use the value received from MQTT for calculations, you might encounter the following errors. | TypeError: unsupported operand type(s) for +: ‘int’ and ‘str’ | TypeError: cannot concatenate ‘str’ and ‘int’ objects | . That’s because the received value is in the form of text (string in python), so we need to convert it before we use it. | You can convert it to a whole number using: last_received_value = int(last_received_value) | Or to a decimal number using: last_received_value = float(last_received_value) | . Acting Machine Diagram . | With the code above we connect to an MQTT client, specify the topic and listen to the data being sent to it. If you want to process the data received you can use the last_received_value variable in the while True loop. | . In the next page we show some useful functions on how to process the data received. Previous Step Next Step . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie-hw-code/step-1.html",
    
    "relUrl": "/assignments/05-walkie-talkie-hw-code/step-1.html"
  },"91": {
    "doc": "Setting up MQTT on your ItsyBitsy",
    "title": "Extra Challenge: Use Advanced Components",
    "content": "Now that you have successfully managed messages from MQTT, you can push your project further by incorporating additional components beyond the standard Connected Interaction Kit. This challenge encourages you to explore and integrate elements that can enhance the interactivity and visual appeal of your design. Below are some components you can experiment with: . | LED Strip (WS2812 / Neopixel) | LED Ring | LED Segment Bar | LCD Screen | Speaker / MP3 Player | Fans | . A basic introduction on how to use these components can be found here below: . Complete Prototyping Components List . Be creative and experiment! This challenge is about exploring new possibilities and applying what you’ve learned to enhance your project. 🚀 . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie-hw-code/step-1.html#extra-challenge-use-advanced-components",
    
    "relUrl": "/assignments/05-walkie-talkie-hw-code/step-1.html#extra-challenge-use-advanced-components"
  },"92": {
    "doc": "Step 2: Code until now",
    "title": "Without Statemachine",
    "content": "import time import board import analogio import digitalio import neopixel # Register sensors sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 while True: # Turn on LED if sound_sensor.value &gt; 30000: leds.fill(color_on) leds.show() timer_mark = time.monotonic() # Turn LED off if time.monotonic() - timer_mark &gt;= timer_duration: leds.fill(color_off) leds.show() . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-2-code.html#without-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-2-code.html#without-statemachine"
  },"93": {
    "doc": "Step 2: Code until now",
    "title": "With statemachine",
    "content": "import time import board import analogio import digitalio import neopixel # States state_on = 0 state_off = 1 current_state = 0 # Register sensors sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 while True: if current_state == state_off: # make sure the LED is off leds.fill(color_off) leds.show() # check if we should turn on if sound_sensor.value &gt; 30000: # Start the timer! timer_mark = time.monotonic() current_state = state_on elif current_state == state_on: leds.fill(color_on) leds.show() if time.monotinic() - timer_mark &gt;= timer_duration: current_state = state_off . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-2-code.html#with-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-2-code.html#with-statemachine"
  },"94": {
    "doc": "Step 2: Code until now",
    "title": "Step 2: Code until now",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-2-code.html",
    
    "relUrl": "/tutorials/coding-challenge/step-2-code.html"
  },"95": {
    "doc": "Step 3: Code until now",
    "title": "Without Statemachine",
    "content": "import time import board import analogio import digitalio import neopixel import random # Register sensors button = digitalio.DigitalInOut(board.D4) button.direction = digitalio.Direction.INPUT sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 triggerd = False while True: # Turn on LED if sound_sensor.value &gt; 30000 and not triggerd: triggerd = True color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) leds.fill(color) leds.show() timer_mark = time.monotonic() if sound_sensor.value &lt; 30000 and triggerd: triggerd = False # Turn LED off if time.monotonic() - timer_mark &gt;= timer_duration: leds.fill(color_off) leds.show() . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-3-code.html#without-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-3-code.html#without-statemachine"
  },"96": {
    "doc": "Step 3: Code until now",
    "title": "With statemachine",
    "content": "import time import board import analogio import digitalio import neopixel import random # States state_on_loud = 0 state_on_quiete = 1 state_off = 2 current_state = state_off # Register sensors sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 color = None triggered = False while True: if current_state == state_off: # make sure the LED is off leds.fill(color_off) leds.show() # check if we should turn on if sound_sensor.value &gt; 30000: # Start the timer! color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) timer_mark = time.monotonic() current_state = state_on_loud elif current_state == state_on_loud: leds.fill(color) leds.show() if time.monotonic() - timer_mark &gt;= timer_duration: current_state = state_off elif sound_sensor.value &lt; 25000: current_state = state_on_quiete elif current_state == state_on_quiete: leds.fill(color) leds.show() if time.monotonic() - timer_mark &gt;= timer_duration: current_state = state_off elif sound_sensor.value &gt; 30000: # Her start the timer! color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) timer_mark = time.monotinic() current_state = state_on_loud . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-3-code.html#with-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-3-code.html#with-statemachine"
  },"97": {
    "doc": "Step 3: Code until now",
    "title": "Step 3: Code until now",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-3-code.html",
    
    "relUrl": "/tutorials/coding-challenge/step-3-code.html"
  },"98": {
    "doc": "Step 4: Code until now",
    "title": "Without Statemachine",
    "content": "import time import board import analogio import digitalio import neopixel import random # Register sensors button = digitalio.DigitalInOut(board.D4) button.direction = digitalio.Direction.INPUT sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 triggerd = False color_list = [] while True: # Replay if button.value is True: for color in color_list: leds.fill(color) leds.show() time.sleep(1) leds.fill(color_off) leds.show() color_list = [] # Turn on LED if sound_sensor.value &gt; 30000 and not triggerd: triggerd = True color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) print(f\"{color}\") color_list.append(color) leds.fill(color) leds.show() timer_mark = time.monotonic() # Don't over trigger time.sleep(0.2) if sound_sensor.value &lt; 30000 and triggerd: triggerd = False # Turn LED off if time.monotonic() - timer_mark &gt;= timer_duration: leds.fill(color_off) leds.show() . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-4-code.html#without-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-4-code.html#without-statemachine"
  },"99": {
    "doc": "Step 4: Code until now",
    "title": "With statemachine",
    "content": "import time import board import analogio import digitalio import neopixel import random # States state_on_loud = 0 state_on_quiete = 1 state_off = 2 state_memory = 3 current_state = state_off # Register sensors button = digitalio.DigitalInOut(board.D4) button.direction = digitalio.Direction.INPUT sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 color = None triggered = False color_memory = [] while True: if current_state == state_off: # make sure the LED is off leds.fill(color_off) leds.show() # check if we should turn on if sound_sensor.value &gt; 30000: # Start the timer! color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) color_memory.append(color) timer_mark = time.monotonic() current_state = state_on_loud elif button.value is True: current_state = state_memory elif current_state == state_on_loud: leds.fill(color) leds.show() if time.monotonic() - timer_mark &gt;= timer_duration: current_state = state_off elif button.value is True: current_state = state_memory elif sound_sensor.value &lt; 25000: current_state = state_on_quiete elif current_state == state_on_quiete: leds.fill(color) leds.show() if time.monotonic() - timer_mark &gt;= timer_duration: current_state = state_off elif button.value is True: current_state = state_memory elif sound_sensor.value &gt; 30000: # Her start the timer! color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) color_memory.append(color) timer_mark = time.monotonic() current_state = state_on_loud elif current_state == state_memory: for color in color_memory: leds.fill(color) leds.show() time.sleep(1) leds.fill(color_off) leds.show() color_memory = [] current_state = state_off . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-4-code.html#with-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-4-code.html#with-statemachine"
  },"100": {
    "doc": "Step 4: Code until now",
    "title": "Step 4: Code until now",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-4-code.html",
    
    "relUrl": "/tutorials/coding-challenge/step-4-code.html"
  },"101": {
    "doc": "Step 1: Preparation",
    "title": "Step 1: Preparation",
    "content": "To follow this tutorial, you will need your ItsyBitsy, a chainable LED, a button, a buzzer, and a servo motor. You will also need materials to construct the Pomodoro Timer embodiment. These materials can be picked up at the faculty. The Pomodoro technique can be described by the following steps: . | Set the pomodoro timer. | Work on the task. | When the timer rings, stop working on the task. | Take a small break. If you’ve had three small breaks, take a longer break instead. | Repeat until task is done. | . These steps will look like this in a state diagram: . Open Mu and create a new file. Add the following template to the file: . ##--- Imports ##--- Variables ##--- Functions ##--- Acting Machine cause functions ##--- Acting machine effect functions ##--- Main loop while True: return . This template provides us with some basic organization for the programming that we will do in the following steps. Save this new file as code.py on your ItsyBitsy. If you already have a code.py file from a previous tutorial, move it over to some place on your computer so you can access it later. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step1.html",
    
    "relUrl": "/tutorials/02-pomodoro/step1.html"
  },"102": {
    "doc": "Step 2: Code until now",
    "title": "Step 2 Code until now",
    "content": "##--- Imports import digitalio import board ##--- Variables # State variables state_idle = 0 state_work = 1 current_state = state_idle # Button variables buttonpin = board.D6 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work # State Work elif current_state == state_work: if check_button_press(): print(\"Switch from Work to Idle\") current_state = state_idle . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step2-code.html#step-2-code-until-now",
    
    "relUrl": "/tutorials/02-pomodoro/step2-code.html#step-2-code-until-now"
  },"103": {
    "doc": "Step 2: Code until now",
    "title": "Step 2: Code until now",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step2-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step2-code.html"
  },"104": {
    "doc": "Step 2: Setting up the states",
    "title": "Step 2.A: Setting up the states",
    "content": "Upon startup, we would like the program to be in an idle state until the user explicitly starts the timer by means of a button press. To do so we will start with implementing two things: . | Variables and logic to handle the different states. | A button to toggle between states. | . First we need to define three variables: state_idle, state_work, and current_state. We represent the different states as integers. We can add these variables under the ##—-Variables paragraph: . ##--- Variables # State variables state_idle = 0 state_work = 1 current_state = state_idle . The integer stored in current_state can then be compared to the different states to decide what next steps to take inside the ##—- Main loop: . ##--- Main loop while True: # State Idle if current_state == state_idle: return # State Work elif current_state == state_work: return . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step2.html#step-2a-setting-up-the-states",
    
    "relUrl": "/tutorials/02-pomodoro/step2.html#step-2a-setting-up-the-states"
  },"105": {
    "doc": "Step 2: Setting up the states",
    "title": "Step 2.B: Implementing a button",
    "content": "To switch between the two states, we can add a button to our system. We’ll need to import the digitalio and board libraries to communicate with the button. ##--- Imports import digitalio import board . Connect the button to pin D6. The following variables allow for communication with the button: . ##--- Variables #... # Button variables buttonpin = board.D6 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT . We will need to create a function that can tell us when the button has been pressed. For this, we need two variables that keep track of the current and previous button states. To do this we can add two new variables in our ##—- Variables paragraph: . ##--- Variables #... current_button_state = False last_button_state = False . When the last recorded button state is false, and the current button state is true, we know the button has been pressed. To use these states we create a function to check if the button is being pressed in the ##—- Functions Paragraph: . ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press . Let’s alter the main loop in our program to switch between the two states once the button is pressed: . ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work # State Work elif current_state == state_work: if check_button_press(): print(\"Switch from Work to Idle\") current_state = state_idle . It’s time to upload your code to the ItsyBitsy and see if it works! Your code should now: . | Output a print statement once the state changes | Switch between states upon button press | . Click here to see the code you should have until now. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step2.html#step-2b-implementing-a-button",
    
    "relUrl": "/tutorials/02-pomodoro/step2.html#step-2b-implementing-a-button"
  },"106": {
    "doc": "Step 2: Setting up the states",
    "title": "Step 2: Setting up the states",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step2.html",
    
    "relUrl": "/tutorials/02-pomodoro/step2.html"
  },"107": {
    "doc": "Step 3: Code until now",
    "title": "Step 3: Code until now",
    "content": "##--- Imports import digitalio import board import neopixel ##--- Variables # State variables state_idle = 0 state_work = 1 current_state = state_idle # Button variables buttonpin = board.D6 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False # For the Chainable LED: pin_leds = board.D10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_green = (0, 255, 0, 0) led_blue = (0, 0, 255, 0) led_yellow = (255, 255, 0, 0) led_white = (255, 255, 255, 0) ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.show() ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work set_led_color(led_green) # State Work elif current_state == state_work: if check_button_press(): print(\"Switch from Work to Idle\") current_state = state_idle set_led_color(led_off) . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step3-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step3-code.html"
  },"108": {
    "doc": "Step 3: Adding the LED",
    "title": "Step 3: Adding the LED",
    "content": "We can switch between two states, and the program prints some output when this switch happens. It would be nice to have a way to show the user which state the program is in now. We can make use of a LED for this. The ItsyBitsy doesn’t have a standard library that can control the Grove Chainable LEDs, so we will need to go through some additional steps for it to work. Follow the tutorial below to get things set up. Using a Grove Chainable LED on the ItsyBitsy . Now we can import the p9813 library, and use it to set up some variables to control the LED. ##--- Imports import neopixel ##--- Variables # For the Chainable LED: pin_leds = board.D10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) . Attach the LED to D3. Let’s create a function that can change the LED’s color. ##--- Functions ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.show() . The LED takes RGB colors, with each channel ranging between 0 and 255. To make things easier on us, we can store some color variables to use later. ##--- Variables led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_green = (0, 255, 0, 0) led_blue = (0, 0, 255, 0) led_yellow = (255, 255, 0, 0) led_white = (255, 255, 255, 0) . Equipped with our new variables and function, we can change the color of the led with only minimal alterations to our original main loop: . ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work set_led_color(led_green) # State Work elif current_state == state_work: if check_button_press(): print(\"Switch from Work to Idle\") current_state = state_idle set_led_color(led_off) . It’s time to upload your code to the ItsyBitsy and see if it works! Your code should now: . | Output a print statement once the state changes | Switch between states upon button press | Turn the LED green when the state changes from idle to work | Turn the LED off when the state changes from work to idle | . Click here to see the code you should have until now. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step3.html",
    
    "relUrl": "/tutorials/02-pomodoro/step3.html"
  },"109": {
    "doc": "Step 4: Code until now",
    "title": "Step 4: Code until now",
    "content": "##--- Imports import digitalio import board import neopixel import time ##--- Variables # State variables state_idle = 0 state_work = 1 current_state = state_idle # Button variables buttonpin = board.D6 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False # For the Chainable LED: pin_leds = board.D10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_green = (0, 255, 0, 0) led_blue = (0, 0, 255, 0) led_yellow = (255, 255, 0, 0) led_white = (255, 255, 255, 0) # Timer variables work_duration = 5 timer_duration = 0 timer_mark = 0 ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.show() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work set_led_color(led_green) set_timer(work_duration) # State Work elif current_state == state_work: if timer_expired(): print(\"Switch from Work to Idle\") current_state = state_idle set_led_color(led_off) . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step4-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step4-code.html"
  },"110": {
    "doc": "Step 4: Creating a timer",
    "title": "Step 4: Creating a timer",
    "content": "Now we’re ready to add in the timer! Import the time library: . ##--- Imports import time . We can replace the transition from state_work to state_idle with a timer. Add the following variables to the program. work_duration stores how long we would like state_work to last. This is set to 5 seconds. timer_duration and timer_mark will be used when setting the timer. timer_mark will store the starting point of the timer. ##--- Variables # Timer variables work_duration = 5 timer_duration = 0 timer_mark = 0 . With these new variables, we can create a function that starts a new timer. We also create a new function that checks when the timer expires. ##--- Functions ##--- Acting machine effect functions def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() ##--- Acting machine cause functions def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False . After altering the main loop to incoorporate the aforementioned functions, we obtain this: . ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work set_led_color(led_green) set_timer(work_duration) # State Work elif current_state == state_work: if timer_expired(): print(\"Switch from Work to Idle\") current_state = state_idle set_led_color(led_off) . Now, we can switch from state_idle to state_work with a button press. Once the button is pressed, a timer starts with the duration of work_duration. Once this timer expires, we transition back to state_idle. It’s time to upload your code to the ItsyBitsy and see if it works! Your code should now: . | Output a print statement once the state changes | Switch from state_work to state_idle when the timer expires | Switch from state_idle to state_work when the button is pressed | Turn the LED green when the state changes from idle to work | Turn the LED off when the state changes from work to idle | . Click here to see the code you should have until now. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step4.html",
    
    "relUrl": "/tutorials/02-pomodoro/step4.html"
  },"111": {
    "doc": "Step 5: Code until now",
    "title": "Step 5: Code until now",
    "content": "##--- Imports import digitalio import board import neopixel import time from analogio import AnalogOut ##--- Variables # State variables state_idle = 0 state_work = 1 state_break_alarm = 2 current_state = state_idle # Button variables buttonpin = board.D6 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False # For the Chainable LED: pin_leds = board.D10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_green = (0, 255, 0, 0) led_blue = (0, 0, 255, 0) led_yellow = (255, 255, 0, 0) led_white = (255, 255, 255, 0) # Timer variables work_duration = 5 timer_duration = 0 timer_mark = 0 # Buzzer variables buzzerpin = board.D12 buzzer = AnalogOut(buzzerpin) ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.show() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def set_buzzer(value): if value == True: buzzer.value = 65535 else: buzzer.value = 0 ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) set_buzzer(True) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): current_state = state_idle set_led_color(led_off) set_buzzer(False) . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step5-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step5-code.html"
  },"112": {
    "doc": "Step 5: Adding an alarm",
    "title": "Step 5: Adding an alarm",
    "content": "Switching between states works now, as does the LED. But when the user’s worktime is over, they aren’t alerted in any way before the LED turns off and the state switches. To make the user aware of their worktime being over, we should add an alarm. First, we add a new state, state_break_alarm. When we are in state_work and the timer expires, we go to state_break_alarm. We also color the LED red. ##--- Imports from analogio import AnalogOut ##--- Variables # State variables state_break_alarm = 2 ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): current_state = state_idle set_led_color(led_off) . Now that we’ve set up the break state, we are ready to implement the actual alarm. We’ll use a buzzer for this. Attach the buzzer to D12. We’ll need to import the AnalogOut function to send information to the buzzer. Then, we also need to write a function that can turn the buzzer on and off. We will be able to pass a value on to this set_buzzer() function. If this value is True, we write 65535 to the buzzer. 65535 is the largest number (and thus, voltage) we can read or output to an Analog port. If we pass False to this function, we write 0 to the buzzer instead. ##--- Variables # Buzzer variables buzzerpin = board.D12 buzzer = AnalogOut(buzzerpin) ##--- Functions ##--- Acting machine effect functions def set_buzzer(value): if value == True: buzzer.value = 65535 else: buzzer.value = 0 . Let’s alter the main loop to incorporate the buzzer, passing True and False to the function wherever the buzzer needs to turn on and off: . ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) set_buzzer(True) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): current_state = state_idle set_led_color(led_off) set_buzzer(False) . It’s time to upload your code to the ItsyBitsy and see if it works! Your code should now: . | Turn the LED green when switching to state_work | Turn the LED red and turn on the buzzer when switching to state_break_alarm | Return to state_idle when pressing the button while in state_break_alarm | . Click here to see the code you should have until now. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step5.html",
    
    "relUrl": "/tutorials/02-pomodoro/step5.html"
  },"113": {
    "doc": "Step 6: Code until now",
    "title": "Step 6: Code until now",
    "content": "##--- Imports import digitalio import board import neopixel import time from analogio import AnalogOut ##--- Variables # State variables state_idle = 0 state_work = 1 state_break_alarm = 2 state_short_break = 3 state_work_alarm = 4 state_long_break = 5 current_state = state_idle # Button variables buttonpin = board.D6 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False # For the Chainable LED: pin_leds = board.D10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_green = (0, 255, 0, 0) led_blue = (0, 0, 255, 0) led_yellow = (255, 255, 0, 0) led_white = (255, 255, 255, 0) # Timer variables work_duration = 5 short_break_duration = 3 long_break_duration = 8 timer_duration = 0 timer_mark = 0 break_counter = 0 # Buzzer variables buzzerpin = board.D12 buzzer = AnalogOut(buzzerpin) ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.show() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def set_buzzer(value): if value == True: buzzer.value = 65535 else: buzzer.value = 0 ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) set_buzzer(True) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): set_buzzer(False) if break_counter &lt; 3: current_state = state_short_break set_led_color(led_blue) set_timer(short_break_duration) break_counter = break_counter + 1 else: current_state = state_long_break set_led_color(led_white) set_timer(long_break_duration) break_counter = 0 # State Short Break elif current_state == state_short_break: if timer_expired(): current_state = state_work_alarm set_led_color(led_yellow) set_buzzer(True) # State Long Break elif current_state == state_long_break: if timer_expired(): current_state = state_idle set_led_color(led_off) set_buzzer(False) # State Work Alarm elif current_state == state_work_alarm: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step6-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step6-code.html"
  },"114": {
    "doc": "Step 6: Adding the breaks",
    "title": "Step 6: Adding the breaks",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step6.html",
    
    "relUrl": "/tutorials/02-pomodoro/step6.html"
  },"115": {
    "doc": "Step 6: Adding the breaks",
    "title": "Step 6.1 Short break",
    "content": "Instead of returning to state_idle, we want to give the user a timed break, which can be either a short break or a long break. We start with the short break. Add state_short_break to your variables. When the break is over, we also want to alert the user that their break is over. This state, state_work_alarm, should also be in your list of variables. We also store its duration in a variable called short_break_duration. It is set to three seconds now: . ##--- Variables # State variables state_short_break = 3 state_work_alarm = 4 # Timer variables short_break_duration = 3 . The functions that we made in the last steps should be enough to implement the behavior we want. We need to add two more elif statements to take the two new states into account. The program should enter state_short_break when state_break_alarm is over, and go into state_work_alarm when the break is over. From state_work_alarm, it should return to state_work. We can make use of the different LED colors to differentiate between all these states. ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) set_buzzer(True) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): current_state = state_short_break set_led_color(led_blue) set_timer(short_break_duration) set_buzzer(False) # State Short Break elif current_state == state_short_break: if timer_expired(): current_state = state_work_alarm set_led_color(led_yellow) set_buzzer(True) # State Work Alarm elif current_state == state_work_alarm: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) . It’s time to upload your code to the ItsyBitsy and see if it works! Your code should now: . | Have the LED turn a different color upon entering a new state | Sound the alarm in states state_break_alarm and state_work_alarm | Give the user a timed break | . Here you can find the code we have until now: ** add link ** . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step6.html#step-61-short-break",
    
    "relUrl": "/tutorials/02-pomodoro/step6.html#step-61-short-break"
  },"116": {
    "doc": "Step 6: Adding the breaks",
    "title": "Step 6.2 Long break",
    "content": "After three short breaks, we want to give the user a long break before they have to go back to work. We need to take into account how many breaks the user has had. Create a new variable called break_counter, a new state called state_long_break, and a variable for the duration: . ##--- Variables break_counter = 0 # State variables state_long_break = 5 # Timer variables long_break_duration = 8 . Now we need to go into state_break_alarm and count the amount of times that the alarm has gone off. If this number is less than 3, we enter state_short_break. If it’s 3 or more, we reset the break_counter back to 0 and enter state_long_break. # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): set_buzzer(False) if break_counter &lt; 3: current_state = state_short_break set_led_color(led_blue) set_timer(short_break_duration) break_counter = break_counter + 1 else: current_state = state_long_break set_led_color(led_white) set_timer(long_break_duration) break_counter = 0 . Now we can add in the behavior for the long break. When the timer runs out, we want to turn off the Pomodoro timer and return to state_idle: . # State Long Break elif current_state == state_long_break: if timer_expired(): current_state = state_idle set_led_color(led_off) set_buzzer(False) . And here we have a functional Pomodoro timer! Upload your code to the ItsyBitsy and see if it works. Click here to see the code you should have until now. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step6.html#step-62-long-break",
    
    "relUrl": "/tutorials/02-pomodoro/step6.html#step-62-long-break"
  },"117": {
    "doc": "Step 7: Code until now",
    "title": "Step 7: Code until now",
    "content": "##--- Imports import digitalio import board import neopixel import time from analogio import AnalogOut import pwmio from adafruit_motor import servo ##--- Variables # State variables state_idle = 0 state_work = 1 state_break_alarm = 2 state_short_break = 3 state_work_alarm = 4 state_long_break = 5 current_state = state_idle # Button variables buttonpin = board.D6 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False # For the Chainable LED: pin_leds = board.D10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_green = (0, 255, 0, 0) led_blue = (0, 0, 255, 0) led_yellow = (255, 255, 0, 0) led_white = (255, 255, 255, 0) # Timer variables work_duration = 5 short_break_duration = 3 long_break_duration = 8 timer_duration = 0 timer_mark = 0 break_counter = 0 # Buzzer variables buzzerpin = board.D12 buzzer = AnalogOut(buzzerpin) # Servo variables pwm = pwmio.PWMOut(board.D14, frequency = 50) my_servo = servo.Servo(pwm) ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.show() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def set_buzzer(value): if value == True: buzzer.value = 65535 else: buzzer.value = 0 def update_servo_angle(): current_time = time.monotonic() if current_time &lt; timer_mark + timer_duration: angle = int((current_time - timer_mark) / timer_duration * 180) my_servo.angle = angle ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) set_buzzer(True) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): set_buzzer(False) if break_counter &lt; 3: current_state = state_short_break set_led_color(led_blue) set_timer(short_break_duration) break_counter = break_counter + 1 else: current_state = state_long_break set_led_color(led_white) set_timer(long_break_duration) break_counter = 0 # State Short Break elif current_state == state_short_break: if timer_expired(): current_state = state_work_alarm set_led_color(led_yellow) set_buzzer(True) # State Long Break elif current_state == state_long_break: if timer_expired(): current_state = state_idle set_led_color(led_off) set_buzzer(False) # State Work Alarm elif current_state == state_work_alarm: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step7-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step7-code.html"
  },"118": {
    "doc": "Step 7: Additional visualization using the servo",
    "title": "Step 7: Additional visualization using the servo",
    "content": "The Pomodoro timer is functional, but we can still improve on the user experience. It would be a good idea to visualize to the user how much time there is left before the next alarm goes off. We can use a servo for this, with its angle being 0 when the timer just starts, going up to 180 when the timer expires. Import the following libaries: . import pwmio from adafruit_motor import servo . Then, add the following variables to the program: . # Servo variables pwm = pwmio.PWMOut(board.D14, frequency = 50) my_servo = servo.Servo(pwm) . Attach the servo to pin D14. We can now control the servo through the my_servo variable. Let’s create a function that updates the servo’s angle. This function should look at the timer variables, timer_mark and timer_duration, as well as the current time, and map these to an angle. We do this by subtracting the minimum time value (timer_mark) from the current time. Then we divide this result by the timer’s duration. This will give us a number between 0 and 1. Multiplying this by our new maximum value, 180, will give us a number between 0 and 180, which we can use as an angle for the servo. Since we only want to use whole numbers, we cast it to an integer before saving it into the angle variable. ##--- Acting machine effect functions def update_servo_angle(): current_time = time.monotonic() if current_time &lt; timer_mark + timer_duration: angle = int((current_time - timer_mark) / timer_duration * 180) my_servo.angle = angle . We can call this function in every state we have a timer in: state_work, state_short_break, and state_long_break. Upload your code to the ItsyBitsy and see if it works. This concludes the programming part of the assignment! . Click here to see the code you should have until now. Last Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step7.html",
    
    "relUrl": "/tutorials/02-pomodoro/step7.html"
  },"119": {
    "doc": "Step 8 Assembling the embodiment",
    "title": "Step 8 Assembling the embodiment",
    "content": "Now with the code functioning and representing the state diagram from step 1, we can move on to giving our pomodoro timer an embodiment. Experiment with different materials, different shapes or perhaps even exchange some sensors for others to make it your own! . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step8.html",
    
    "relUrl": "/tutorials/02-pomodoro/step8.html"
  },"120": {
    "doc": "Triggering different sequences based on context or interaction",
    "title": "Triggering different sequences based on context or interaction",
    "content": "How could we trigger different sequences based on user or context interaction? In this example, we will create a little ItsyCreature that sleeps peacefully until disturbed – in that case it wakes up and gets angry at the disturbance! . Connect the Chainable LED to pin D6, the Servo Motor to pin D10 and the Touch Sensor to D8. By default, the creature will “sleep” in peace, but when touched get angry until the sensor is released again. ##--- Library Imports import time import board import neopixel import pwmio import digitalio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup # Add a touch sensor touch = digitalio.DigitalInOut(board.D8) touch.direction = digitalio.Direction.INPUT pin_leds = board.D6 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) pwm = pwmio.PWMOut(board.D10, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence_sleep = [ (80, 3, 80, \"QuadEaseIn\"), (80, 2, 1, \"LinearInOut\"), (0, 3, 80, \"QuadEaseInOut\"), (0, 2, 1, \"LinearInOut\") ] led_sequence_angry = [ (MAX_LED, 0.01, 1, \"QuadEaseInOut\"), (MIN_LED, 0.01, 1, \"QuadEaseInOut\") ] servo_sequence_sleep = [ (0, 1.0, 1, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (0, 10.0, 11, \"LinearInOut\") ] servo_sequence_angry = [ (10, 0.01, 1, \"LinearInOut\"), (MIN_SERVO, 0.01, 1, \"LinearInOut\") ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.show() ##--- Main loop while True: if touch.value == False: print(\"sleeping 😴\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_sleep, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED White led_value = int(position_led) leds.fill((0, 0, 0, led_value)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_sleep, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo elif touch.value == True: print(\"angry!!! 😡\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_angry, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED Red led_value = int(position_led) leds.fill((led_value, 0, 0)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_angry, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo time.sleep(0.05) . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/trigger-different-sequences-index.html",
    
    "relUrl": "/assignments/07+08-animistic-design/trigger-different-sequences-index.html"
  },"121": {
    "doc": "VarSpeed Library Guide",
    "title": "VarSpeed Library Guide",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/varspeed-library-guide.html",
    
    "relUrl": "/assignments/07+08-animistic-design/varspeed-library-guide.html"
  },"122": {
    "doc": "VarSpeed Library Guide",
    "title": "Download and Install",
    "content": "For the code to work, we need an additional library that helps us with controlling different sequences for LEDs, motors, etc. | Download the library here | Unzip the library and add the files varspeed.py and easing_functions.py into the lib folder of your CIRCUITPY | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/varspeed-library-guide.html#download-and-install",
    
    "relUrl": "/assignments/07+08-animistic-design/varspeed-library-guide.html#download-and-install"
  },"123": {
    "doc": "VarSpeed Library Guide",
    "title": "Why use the VarSpeed library?",
    "content": "When trying to animate an LED, a servo motor, or any kind of actuator, we have to set its value. This might be the LED color, the motor angle, vibration strength – you name it. Usually, we would solve this manually by setting a new value and then a time.sleep() like this code that blinks the Chainable LED. # --- Main loop while True: print(\"hello world\") leds.fill((0, 0, 255)) leds.write() time.sleep(2) leds.fill((0, 0, 0)) leds.write() time.sleep(2) . The issue with this code is, that the time.sleep(2) function actually blocks our entire main loop for two seconds, before continuing. If we want to still read sensors while blinking our LED, or want to move another actuator at a different interval, we run into issues. The VarSpeed library solves this issue neatly by allowing us to define actuator behaviour in a simple way. In the code below, we can easily define a sequence of movements for our servo motor by providing four inputs: . | A target-value, | Time to get to that value (in seconds), | Number of steps to get there, | An easing function (see: easing functions) | . All this without having to worry about our code being blocked by a time.sleep() function. Take a look at the code examples to get a better understanding of the library and how you can use it to bring your creature to life! . ##--- Custom Movement Sequence # The sequence will go through each entry and move to the next entry # The sequence is defined with this format: (next-position, seconds-to-move, number-of-steps, easing-function) # Take a look at different easing functions here: https://easings.net servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Go to value 180, in 5 seconds, in 100 steps, and use a linear easing function. (0, 2.0, 5, \"QuadEaseOut\"), # Go to value 0, in 2 seconds, in 5 steps, and use a QuadEaseOut easing function (90, 2.0, 10, \"SineEaseInOut\") # Go to value 90, in 2 seconds, in 10 steps, and use a SineEaseInOut easing function ] . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/varspeed-library-guide.html#why-use-the-varspeed-library",
    
    "relUrl": "/assignments/07+08-animistic-design/varspeed-library-guide.html#why-use-the-varspeed-library"
  },"124": {
    "doc": "VarSpeed Library Guide",
    "title": "Detailed example with a servo",
    "content": "In this example we will take a detailed look at how to use the VarSpeed library to gradually move a servo. | As always, we start by importing all the libraries we need to run our code. ##--- Library Imports import time import board import pwmio from adafruit_motor import servo from varspeed import Vspeed . | Next, we need to configure the VarSpeed library and define what the minimum and maximum values of our sequence will be as well as pass these values on to the library itself. For the result we chose int because our output should only contain whole numbers. ##--- VarSpeed Variables MIN = 0 # The minimum possible value of our component MAX = 180 # The maximum possible value of our component vs = Vspeed(init_position=MIN, result=\"int\") # init_position = initial start position // result = float, int vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # make the output of the function be within the bounds set . | Afterwards we can configure our servo motor by defining the pin we connect it to (Pin D2), creating a variable for the motor we can use to steer it, and set an initial angle. If you haven’t worked with a servo before, take a look at its documentation page. | . | PicoExpander | BitsyExpander | . | ##--- Hardware Setup pwm = pwmio.PWMOut(board.GP10, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN # set the servo to a known starting point . | ##--- Hardware Setup pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN # set the servo to a known starting point . | . | Now instead of having to fiddle with code ourselves to define the motor movement, we can do so by writing it into a sequence that then gets interpreted by the VarSpeed library into the actual angle values. You can add as many entries into the servo_sequence array as you like, as well as define the servo_looping to define how often the sequence should be executed. Learn more about different looping functions here: https://easings.net . ##--- Custom Movement Sequence # This is where we can define the movement of our motor # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Go to 180, in 5 seconds, in 100 steps, using a linear function (0, 2.0, 5, \"QuadEaseOut\"), # Go to 0, in 2 seconds, in 5 steps, using a quadratic easing function (90, 2.0, 10, \"SineEaseInOut\") # Got to 90, in 2 seconds, in 10 steps, using a sine function ] # Define how many times the defined sequence should be repeated #servo_looping = 0 # play the sequence in an endless loop forever servo_looping = 1 # play the sequence only once #servo_looping = 10 # play the sequence 10 times . | The last thing to do is to add our main loop, so that the code gets executed continuously. ##--- Main loop while True: # Make a call to the library and request the desired of our servo motor position, running, changed = vs.sequence(sequence=servo_sequence, loop_max=servo_looping) # - Position: The new value to assign to our servo # - Running: False if the sequence is finished, True if it's still running # - Changed: False if the value hasn't changed since the last function call, True if it has # See if the values changed for the next move, then do so if changed: print(f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') my_servo.angle = position . Let’s have a look at the following statement: . position, running, changed = vs.sequence(sequence=servo_sequence, loop_max=servo_looping) . What happens here is that the VarSpeed library contains a function sequence() which takes two variables: the desired sequence (servo_sequence) and the amount of loops (servo_looping). It also returns three variables: . | The current position in the sequence (position) | Whether the sequence is running (running) | If the value has changed (changed) | . | . Combined together, the final code for controlling a servo motor with a sequence is this: . ##--- Library Imports import time import board import pwmio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN = 0 # The minimum possible value of our component MAX = 180 # The maximum possible value of our component vs = Vspeed(init_position=MIN, result=\"int\") # init_position = initial start position // result = float, int vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # make the output of the function be within the bounds set ##--- Hardware Setup pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the movement of our motor # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Go to 180, in 5 seconds, in 100 steps, using a linear function (0, 2.0, 5, \"QuadEaseOut\"), # Go to 0, in 2 seconds, in 5 steps, using a quadratic easing function (90, 2.0, 10, \"SineEaseInOut\") # Got to 90, in 2 seconds, in 10 steps, using a sine function ] # Define how many times the defined sequence should be repeated #servo_looping = 0 # play the sequence in an endless loop forever servo_looping = 1 # play the sequence only once #servo_looping = 10 # play the sequence 10 times while True: # Make a call to the library and request the desired of our servo motor position, running, changed = vs.sequence(sequence=servo_sequence, loop_max=servo_looping) # - Position: The new value to assign to our servo # - Running: False if the sequence is finished, True if it's still running # - Changed: False if the value hasn't changed since the last function call, True if it has # See if the values changed for the next move, then do so if changed: print(f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') my_servo.angle = position time.sleep(0.1) . Go back to the assignment . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/varspeed-library-guide.html#detailed-example-with-a-servo",
    
    "relUrl": "/assignments/07+08-animistic-design/varspeed-library-guide.html#detailed-example-with-a-servo"
  }
}
