{"0": {
    "doc": "Code solution",
    "title": "Solution",
    "content": "while True: if button.value is True: if current_state is state_wait: keyboard.press(key) # Send our defined key as a command... print(\"button is pressed\") #Print a confirmation in the serial monitor keyboard.release_all() # and release all keys again current_state = state_button_is_pressed # Update our state elif button.value is False: if current_state is state_button_is_pressed: print(\"button is released\") # Print a confirmation in the serial monitor current_state = state_wait # Reset the state # Sleep for a bit to make the keypress events occur at a human timescale # Skilled gamers can do ~7 button presses per second (says ChatGPT) time.sleep(0.143) . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/code_solution.html#solution",
    
    "relUrl": "/assignments/03-game-controller/code_solution.html#solution"
  },"1": {
    "doc": "Code solution",
    "title": "Code solution",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/code_solution.html",
    
    "relUrl": "/assignments/03-game-controller/code_solution.html"
  },"2": {
    "doc": "Code instructions",
    "title": "Variables",
    "content": "A variable is like a box that stores information for your program. You can declare a variable and give it a value, and later change that value if needed. score = 5 # Declares a variable named \"score\" and assigns it a value of 5 score = 6 # Updates the value of \"score\" to 6 . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/coding_instructions.html#variables",
    
    "relUrl": "/assignments/03-game-controller/coding_instructions.html#variables"
  },"3": {
    "doc": "Code instructions",
    "title": "If-Else statements",
    "content": "if , elif and else statements help your program choose between different actions based on conditions. current_state = 0 if buttun_pressed is True: current_state = 1 else: current_state = 0 . In the previous example our code checks whether the button has been pressed, if that’s the case then current_state will be updated to have value 1. Here’s how to use each statement: . | if: States the First condition, can be used on its own | else: States the Last and fallback condition, must either follow an if or elif | elif: States an alternative condition after an if, must either follow an if or elif | . The main difference between else and elif is that elif can have condition parameters, while else cannot, for example: . condition = False if condition is True: print('Condition satisfied!') elif button_is_pressed is True: print('Button is pressed!') else: print('Idle') . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/coding_instructions.html#if-else-statements",
    
    "relUrl": "/assignments/03-game-controller/coding_instructions.html#if-else-statements"
  },"4": {
    "doc": "Code instructions",
    "title": "While loops",
    "content": "While loops are parts of code that are repeated, like the name suggests, while a certain condition is satisfied . while button_is_pressed: print('Button is pressed!') # Print while button is pressed button_is_pressed = button.value # Detect button press . Keep in mind that only the code inside the while block will be executed as long as the condition is satisfied, thus it’s important to update the variable checking the condition if we want to exit the loop at some point. Small note: writing button_is_pressed is True and button_is_pressed is essentially the same thing, although the first one makes it easier to understand the code while reading it. The most common while loop you will see during this course is the while True: loop. This loop defines the behavior that your code will keep repeating while it’s on. Remember to always include time.sleep(0.1) at the end of your while True: loop, this prevents it to execute your code too fast and overwhelm the board. while True: # Your code logic here.... time.sleep(0.1) . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/coding_instructions.html#while-loops",
    
    "relUrl": "/assignments/03-game-controller/coding_instructions.html#while-loops"
  },"5": {
    "doc": "Code instructions",
    "title": "Code instructions",
    "content": "Coding can look like a super complicated skill to learn, but if we decompose each component and learn them individually it can turn out to be quite easy! . In this tutorial we will present 3 basic components, mainly: . | Variables -&gt; Used for storing values | If-else statements -&gt; Used for decision making | While loops -&gt; Used to easily repeat operations | . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/coding_instructions.html",
    
    "relUrl": "/assignments/03-game-controller/coding_instructions.html"
  },"6": {
    "doc": "Fading and blinking a Chainable LED",
    "title": "Fading and blinking a Chainable LED",
    "content": "This example uses a Chainable LED, Please select the type of LED that you are using. | Chainable RGB/W LED (ChaiNEO) | Chainable RGB LED (Grove) | . | | | . | Code | Code | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led-index.html",
    
    "relUrl": "/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led-index.html"
  },"7": {
    "doc": "Game code for ChaiNEO",
    "title": "Reaction Game",
    "content": "In this weeks assignment we are going to build a simple reaction game and embody it in different shapes and forms. ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/game_code_neopixel.html#reaction-game",
    
    "relUrl": "/assignments/02-reaction-game/game_code_neopixel.html#reaction-game"
  },"8": {
    "doc": "Game code for ChaiNEO",
    "title": "Game logic and hardware involved",
    "content": "The basic game makes use of two input components (either Touch Sensor or Tactile Switch), and a Chainable RGB LED as an output. Once the LED turns white, both players have to try and touch their sensor as quick as possible. Whoever is faster wins the round, and the LED will light up in the corresponding color. ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/game_code_neopixel.html#game-logic-and-hardware-involved",
    
    "relUrl": "/assignments/02-reaction-game/game_code_neopixel.html#game-logic-and-hardware-involved"
  },"9": {
    "doc": "Game code for ChaiNEO",
    "title": "Connecting the cables",
    "content": "Your ItsyBitsy has several connection ports on it. To be sure that your code works properly, you need to make sure that the ports to which you connected your components are the same used in your code. For example, if you connect a component to port D7, you need to use the following code to reference it: . | | . ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/game_code_neopixel.html#connecting-the-cables",
    
    "relUrl": "/assignments/02-reaction-game/game_code_neopixel.html#connecting-the-cables"
  },"10": {
    "doc": "Game code for ChaiNEO",
    "title": "Code for the game",
    "content": "We provide you with the basic code for the game. Copy this code into your code.py file and connect all hardware components to have a basic game ready. Look through the code and use the examples from the previous section to deduce where to connect your components! . | PicoExpander | BitsyExpander | . | ##--- Imports import digitalio import board import neopixel import time import random ##--- Variables state_wait = 0 state_start_game = 1 state_wait_button_press = 2 state_red_wins = 3 state_blue_wins = 4 current_state = 0 # Button variables red_pin = board.GP6 red_button = digitalio.DigitalInOut(red_pin) red_button.direction = digitalio.Direction.INPUT blue_pin = board.GP8 blue_button = digitalio.DigitalInOut(blue_pin) blue_button.direction = digitalio.Direction.INPUT # For the Chainable LED: pin_leds = board.GP10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_blue = (0, 0, 255, 0) led_white = (0, 0, 0, 255) # Timer variables timer_duration = 0 timer_mark = 0 ##--- Functions def set_led_color(color): global leds leds.fill(color) leds.show() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Main loop while True: if current_state == state_wait: set_led_color(led_off) set_timer(random.randint(3, 10)) print(\"starting game!\") current_state = state_start_game elif current_state == state_start_game: if timer_expired(): print(\"timer expired, press your buttons!\") set_led_color(led_white) current_state = state_wait_button_press elif current_state == state_wait_button_press: if red_button.value: print(\"red won\") current_state = state_red_wins elif blue_button.value: print(\"blue won\") current_state = state_blue_wins elif current_state == state_blue_wins: set_led_color(led_blue) time.sleep(3) current_state = state_wait elif current_state == state_red_wins: set_led_color(led_red) time.sleep(3) current_state = state_wait . | ##--- Imports import digitalio import board import neopixel import time import random ##--- Variables state_wait = 0 state_start_game = 1 state_wait_button_press = 2 state_red_wins = 3 state_blue_wins = 4 current_state = 0 # Button variables red_pin = board.D7 red_button = digitalio.DigitalInOut(red_pin) red_button.direction = digitalio.Direction.INPUT blue_pin = board.D13 blue_button = digitalio.DigitalInOut(blue_pin) blue_button.direction = digitalio.Direction.INPUT # For the Chainable LED: pin_leds = board.D3 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_blue = (0, 0, 255, 0) led_white = (0, 0, 0, 255) # Timer variables timer_duration = 0 timer_mark = 0 ##--- Functions def set_led_color(color): global leds leds.fill(color) leds.show() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Main loop while True: if current_state == state_wait: set_led_color(led_off) set_timer(random.randint(3, 10)) print(\"starting game!\") current_state = state_start_game elif current_state == state_start_game: if timer_expired(): print(\"timer expired, press your buttons!\") set_led_color(led_white) current_state = state_wait_button_press elif current_state == state_wait_button_press: if red_button.value: print(\"red won\") current_state = state_red_wins elif blue_button.value: print(\"blue won\") current_state = state_blue_wins elif current_state == state_blue_wins: set_led_color(led_blue) time.sleep(3) current_state = state_wait elif current_state == state_red_wins: set_led_color(led_red) time.sleep(3) current_state = state_wait . | . ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/game_code_neopixel.html#code-for-the-game",
    
    "relUrl": "/assignments/02-reaction-game/game_code_neopixel.html#code-for-the-game"
  },"11": {
    "doc": "Game code for ChaiNEO",
    "title": "Game code for ChaiNEO",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/game_code_neopixel.html",
    
    "relUrl": "/assignments/02-reaction-game/game_code_neopixel.html"
  },"12": {
    "doc": "Game code for Grove",
    "title": "Reaction Game",
    "content": "In this weeks assignment we are going to build a simple reaction game and embody it in different shapes and forms. ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/game_code_p9813.html#reaction-game",
    
    "relUrl": "/assignments/02-reaction-game/game_code_p9813.html#reaction-game"
  },"13": {
    "doc": "Game code for Grove",
    "title": "Game logic and hardware involved",
    "content": "The basic game makes use of two input components (either Touch Sensor or Tactile Switch), and a Chainable RGB LED as an output. Refer to the component page for the Grove Chainable RGB LED , to obtain the P9813.py Python module. Once the LED turns white, both players have to try and touch their sensor as quick as possible. Whoever is faster wins the round, and the LED will light up in the corresponding color. ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/game_code_p9813.html#game-logic-and-hardware-involved",
    
    "relUrl": "/assignments/02-reaction-game/game_code_p9813.html#game-logic-and-hardware-involved"
  },"14": {
    "doc": "Game code for Grove",
    "title": "Connecting the cables",
    "content": "Your ItsyBitsy has several connection ports on it. To be sure that your code works properly, you need to make sure that the ports to which you connected your components are the same used in your code. For example, if you connect a component to port D7, you need to use the following code to reference it: . | | . ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/game_code_p9813.html#connecting-the-cables",
    
    "relUrl": "/assignments/02-reaction-game/game_code_p9813.html#connecting-the-cables"
  },"15": {
    "doc": "Game code for Grove",
    "title": "Code for the game",
    "content": "We provide you with the basic code for the game. Copy this code into your code.py file and connect all hardware components to have a basic game ready. Look through the code and use the examples from the previous section to deduce where to connect your components! . | PicoExpander | BitsyExpander | . | ##--- Imports import digitalio import board import p9813 import time import random ##--- Variables state_wait = 0 state_start_game = 1 state_wait_button_press = 2 state_red_wins = 3 state_blue_wins = 4 current_state = 0 # Button variables red_pin = board.D7 red_button = digitalio.DigitalInOut(red_pin) red_button.direction = digitalio.Direction.INPUT blue_pin = board.D13 blue_button = digitalio.DigitalInOut(blue_pin) blue_button.direction = digitalio.Direction.INPUT # For the Chainable LED: pin_clk = board.D3 pin_data = board.D4 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) led_off = (0, 0, 0) led_red = (255, 0, 0) led_blue = (0, 0, 255) led_white = (255, 255, 255) # Timer variables timer_duration = 0 timer_mark = 0 ##--- Functions def set_led_color(color): global leds leds.fill(color) leds.write() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Main loop while True: if current_state == state_wait: set_led_color(led_off) set_timer(random.randint(3, 10)) print(\"starting game!\") current_state = state_start_game elif current_state == state_start_game: if timer_expired(): print(\"timer expired, press your buttons!\") set_led_color(led_white) current_state = state_wait_button_press elif current_state == state_wait_button_press: if red_button.value: print(\"red won\") current_state = state_red_wins elif blue_button.value: print(\"blue won\") current_state = state_blue_wins elif current_state == state_blue_wins: set_led_color(led_blue) time.sleep(3) current_state = state_wait elif current_state == state_red_wins: set_led_color(led_red) time.sleep(3) current_state = state_wait . | ##--- Imports import digitalio import board import p9813 import time import random ##--- Variables state_wait = 0 state_start_game = 1 state_wait_button_press = 2 state_red_wins = 3 state_blue_wins = 4 current_state = 0 # Button variables red_pin = board.GP6 red_button = digitalio.DigitalInOut(red_pin) red_button.direction = digitalio.Direction.INPUT blue_pin = board.GP8 blue_button = digitalio.DigitalInOut(blue_pin) blue_button.direction = digitalio.Direction.INPUT # For the Chainable LED: pin_clk = board.GP10 pin_data = board.GP11 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) led_off = (0, 0, 0) led_red = (255, 0, 0) led_blue = (0, 0, 255) led_white = (255, 255, 255) # Timer variables timer_duration = 0 timer_mark = 0 ##--- Functions def set_led_color(color): global leds leds.fill(color) leds.write() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Main loop while True: if current_state == state_wait: set_led_color(led_off) set_timer(random.randint(3, 10)) print(\"starting game!\") current_state = state_start_game elif current_state == state_start_game: if timer_expired(): print(\"timer expired, press your buttons!\") set_led_color(led_white) current_state = state_wait_button_press elif current_state == state_wait_button_press: if red_button.value: print(\"red won\") current_state = state_red_wins elif blue_button.value: print(\"blue won\") current_state = state_blue_wins elif current_state == state_blue_wins: set_led_color(led_blue) time.sleep(3) current_state = state_wait elif current_state == state_red_wins: set_led_color(led_red) time.sleep(3) current_state = state_wait . | . ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/game_code_p9813.html#code-for-the-game",
    
    "relUrl": "/assignments/02-reaction-game/game_code_p9813.html#code-for-the-game"
  },"16": {
    "doc": "Game code for Grove",
    "title": "Game code for Grove",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/game_code_p9813.html",
    
    "relUrl": "/assignments/02-reaction-game/game_code_p9813.html"
  },"17": {
    "doc": "1: Digital Interfaces Safari",
    "title": "Digital Interfaces Safari",
    "content": ". ",
    "url": "/Digital-Interfaces/test/assignments/01-digital-interface-safari/#digital-interfaces-safari",
    
    "relUrl": "/assignments/01-digital-interface-safari/#digital-interfaces-safari"
  },"18": {
    "doc": "1: Digital Interfaces Safari",
    "title": "Links",
    "content": "What is a computer? (Eames) . Switch Inspiration Machine ✨ . Additional Switch Inspiration (Lo-fi prototyping) . ",
    "url": "/Digital-Interfaces/test/assignments/01-digital-interface-safari/#links",
    
    "relUrl": "/assignments/01-digital-interface-safari/#links"
  },"19": {
    "doc": "1: Digital Interfaces Safari",
    "title": "Workshop assignment - Creating Switches",
    "content": "As seen in the introduction lecture, a switch can have many shapes, forms and interactive properties. In its most basic form, a switch is a device that changes directly from one state to the other. It is either True or False. In this assignment you are going to design and build three different, hopefully very creative switches (inpiration in the links above). | Go to our ✨ Switch Inspiration Machine ✨ to generate a novel design brief. You don’t need to use it, but its constraints might help you along in your creative process and guide your design. Take a screenshot of the brief for later reference. | Come up with at least three different switches. Be as creative and diverse in the ideas as possible. | From your list of ideas, pick your three favourite / most interesting designs. | Gather some scrap material from the Studio, build quick prototypes of the three switches. Although not having any electronic components build inside, the form should allow the design to go from one state to the other when operated by a user. | Keep the designs to test later on with your peers. | . ",
    "url": "/Digital-Interfaces/test/assignments/01-digital-interface-safari/#workshop-assignment---creating-switches",
    
    "relUrl": "/assignments/01-digital-interface-safari/#workshop-assignment---creating-switches"
  },"20": {
    "doc": "1: Digital Interfaces Safari",
    "title": "1: Digital Interfaces Safari",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/01-digital-interface-safari/",
    
    "relUrl": "/assignments/01-digital-interface-safari/"
  },"21": {
    "doc": "2: Reaction Game",
    "title": "Reaction Game",
    "content": "In this weeks assignment we are going to build a simple reaction game and embody it in different shapes and forms. ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/#reaction-game",
    
    "relUrl": "/assignments/02-reaction-game/#reaction-game"
  },"22": {
    "doc": "2: Reaction Game",
    "title": "Coding Instructions",
    "content": "In this tutorial, you’ll learn how to set up a CircuitPython program to bring your microcontroller, buttons, and LED to life. We’ll guide you through an example designed to match the behavior outlined in the Acting Machine Diagram (shown below). Take your time to study the code and understand how everything fits together. As you work through the tutorial, you’ll explore key Python concepts such as declaring variables, using loops (while), making decisions with if and elif statements, and defining and using functions. Additionally, you’ll learn to work with the neopixel library to control LED colors, giving your prototype a vibrant and interactive feel. By the end, you’ll have an understanding of how to run code on your board, how to connect components and a rough idea of how the code is structured. ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/#coding-instructions",
    
    "relUrl": "/assignments/02-reaction-game/#coding-instructions"
  },"23": {
    "doc": "2: Reaction Game",
    "title": "Game hardware and control flow",
    "content": "The basic game makes use of two input components (either Touch Sensor or Tactile Switch), and a Chainable RGB LED as an output. Once the LED turns white, both players have to try and touch their sensor as quick as possible. Whoever is faster wins the round, and the LED will light up in the color of the winner. The image above shows the minimal components you need to make the technology work. The diagram shows the control flow of the game. We will go into more detail of explaining about Acting Machine Diagrams later. For now you can already interpret how the control might flow if you start in the state (circle) labeled “wait” and then traverse the transitions (arrows) from state to state. ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/#game-hardware-and-control-flow",
    
    "relUrl": "/assignments/02-reaction-game/#game-hardware-and-control-flow"
  },"24": {
    "doc": "2: Reaction Game",
    "title": "Game code",
    "content": "There is a simple way to derive a program that implement the control flow from the Acting Machine Diagram, we have already done that for you! . In order to navigate to the right code you first have to identify the LED form factor of the LEDs in your Connected Interaction Kit. Match the LED in your kit with one of the images below, then access the game code by pressing the button under the matching image. | Chainable RGB/W LED (ChaiNEO) | Chainable RGB LED (Grove) | . | | | . | Code for the game | Code for the game | . ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/#game-code",
    
    "relUrl": "/assignments/02-reaction-game/#game-code"
  },"25": {
    "doc": "2: Reaction Game",
    "title": "Extra Challenge: Make It Better!",
    "content": "Congratulations on getting the basic version of the game running! Now it’s time to put on your problem-solving hats and improve the game! The code you’ve been working with has a few intentional bugs. One key challenge involves the way button presses are handled: . Hint: If you keep a button pressed before the LED turns white, you’ll always win. That doesn’t sound very fair, does it? . Your task is to identify and fix this bug so the game works as intended. Look through the code and think of how you could achieve this, maybe also penalizing a player if they press the button before the led turns white! . ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/#extra-challenge-make-it-better",
    
    "relUrl": "/assignments/02-reaction-game/#extra-challenge-make-it-better"
  },"26": {
    "doc": "2: Reaction Game",
    "title": "2: Reaction Game",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/02-reaction-game/",
    
    "relUrl": "/assignments/02-reaction-game/"
  },"27": {
    "doc": "7+8: Animistic Design",
    "title": "Animistic Design",
    "content": "In the coming two weeks, we are creating an animistic creature – a digital interface that seems alive through different behaviors! . After exploring non-blocking code in the Party Lamp assignment, we will now apply these concepts to create more complex interactive behaviors. This assignment focuses on creating an object with at least two different (opposing) behavioral states that can be triggered by sensors and expressed through various outputs. ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#animistic-design",
    
    "relUrl": "/assignments/07+08-animistic-design/#animistic-design"
  },"28": {
    "doc": "7+8: Animistic Design",
    "title": "Assignment Overview",
    "content": "Your task is to design and program an animistic creature that has a distinct personality expressed through at least two opposing behavioral states (e.g., calm/agitated, shy/curious, sleeping/awake). Your prototype should respond to sensor inputs and change its behavior depending on the state it is in. ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#assignment-overview",
    
    "relUrl": "/assignments/07+08-animistic-design/#assignment-overview"
  },"29": {
    "doc": "7+8: Animistic Design",
    "title": "The VarSpeed library",
    "content": "Last week we experimented with timers to write non-blocking code. This allowed us to check if a button was being pressed even while fading a led. But using timers is not the only way to achieve this. A different approach involves using the *VarSpeed library. Go through the page below to learn what the VarSpeed library does and how to use it, then come back to this page once you’re done. VarSpeed Library Guide . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#the-varspeed-library",
    
    "relUrl": "/assignments/07+08-animistic-design/#the-varspeed-library"
  },"30": {
    "doc": "7+8: Animistic Design",
    "title": "Coding assignment",
    "content": "Your assignment is to design your own acting diagram and then implement it in the code. Here below we provide a code template to help you get started. ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#coding-assignment",
    
    "relUrl": "/assignments/07+08-animistic-design/#coding-assignment"
  },"31": {
    "doc": "7+8: Animistic Design",
    "title": "Code Template",
    "content": ". | PicoExpander | BitsyExpander | . | ##--- Main Loop import board import neopixel import digitalio import time import pwmio from varspeed import Vspeed # -- Define states # TODO: Change variables according to your behaviours names state_behaviour_1 = 0 state_behaviour_2 = 1 #state_behaviour_3 = 2 current_state = state_behaviour_1 # -- Initialize the NeoPixel led_pin = board.GP10 led = neopixel.NeoPixel(led_pin, 1, brightness=0.5, auto_write=False, pixel_order=neopixel.GRBW) # Define basic led colors led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_green = (0, 255, 0, 0) led_blue = (0, 0, 255, 0) led_white = (0, 0, 0, 255) def set_led_color(color): global led led.fill(color) led.show() ##-- VarSpeed Variables # TODO: Change according to your component MIN = 0 # The minimum possible value of our component MAX = 255 # The maximum possible value of our component # init_position = initial start position - result = \"float\", \"int\" vs = Vspeed(init_position=MIN, result=\"int\") # make the output of the function be within the bounds set vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # TODO: Define your sequence my_sequence = [ ] # Define how many times the defined sequence should be repeated looping = 0 # play the sequence in an endless loop forever #looping = 1 # play the sequence only once #looping = 10 # play the sequence 10 times while True: # Make a call to the library and request the parameters position, running, changed = vs.sequence(sequence=my_sequence, loop_max=looping) # - Position: The new value to assign to our servo # - Running: False if the sequence is finished, True if it's still running # - Changed: False if the value hasn't changed since the last function call, True if it has # See if the values changed for the next move, then do so if changed: print(f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') # ----------------------------------------------------------------| # | # Use your own Acting Machine Diagram to program your interaction | # | # ----------------------------------------------------------------| # ---------------------------------------------- # v DO NOT CHANGE ANYTHING BELOW THIS POINT v | # ---------------------------------------------- led.show() time.sleep(0.1) . | ```python ##— Main Loop import board import neopixel import digitalio import time import pwmio from varspeed import Vspeed . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#code-template",
    
    "relUrl": "/assignments/07+08-animistic-design/#code-template"
  },"32": {
    "doc": "7+8: Animistic Design",
    "title": "– Define states",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#-define-states",
    
    "relUrl": "/assignments/07+08-animistic-design/#-define-states"
  },"33": {
    "doc": "7+8: Animistic Design",
    "title": "TODO: Change variables according to your behaviours names",
    "content": "state_behaviour_1 = 0 state_behaviour_2 = 1 #state_behaviour_3 = 2 . current_state = state_behaviour_1 . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#todo-change-variables-according-to-your-behaviours-names",
    
    "relUrl": "/assignments/07+08-animistic-design/#todo-change-variables-according-to-your-behaviours-names"
  },"34": {
    "doc": "7+8: Animistic Design",
    "title": "– Initialize the NeoPixel",
    "content": "led_pin = board.D13 . led = neopixel.NeoPixel(led_pin, 1, brightness=0.5, auto_write=False, pixel_order=neopixel.GRBW) . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#-initialize-the-neopixel",
    
    "relUrl": "/assignments/07+08-animistic-design/#-initialize-the-neopixel"
  },"35": {
    "doc": "7+8: Animistic Design",
    "title": "Define basic led colors",
    "content": "led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_green = (0, 255, 0, 0) led_blue = (0, 0, 255, 0) led_white = (0, 0, 0, 255) . def set_led_color(color): global led led.fill(color) led.show() . ##– VarSpeed Variables . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#define-basic-led-colors",
    
    "relUrl": "/assignments/07+08-animistic-design/#define-basic-led-colors"
  },"36": {
    "doc": "7+8: Animistic Design",
    "title": "TODO: Change according to your component",
    "content": "MIN = 0 # The minimum possible value of our component MAX = 255 # The maximum possible value of our component . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#todo-change-according-to-your-component",
    
    "relUrl": "/assignments/07+08-animistic-design/#todo-change-according-to-your-component"
  },"37": {
    "doc": "7+8: Animistic Design",
    "title": "init_position = initial start position - result = “float”, “int”",
    "content": "vs = Vspeed(init_position=MIN, result=”int”) . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#init_position--initial-start-position---result--float-int",
    
    "relUrl": "/assignments/07+08-animistic-design/#init_position--initial-start-position---result--float-int"
  },"38": {
    "doc": "7+8: Animistic Design",
    "title": "make the output of the function be within the bounds set",
    "content": "vs.set_bounds(lower_bound=MIN, upper_bound=MAX) . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#make-the-output-of-the-function-be-within-the-bounds-set",
    
    "relUrl": "/assignments/07+08-animistic-design/#make-the-output-of-the-function-be-within-the-bounds-set"
  },"39": {
    "doc": "7+8: Animistic Design",
    "title": "TODO: Define your sequence",
    "content": "my_sequence = [ . ] . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#todo-define-your-sequence",
    
    "relUrl": "/assignments/07+08-animistic-design/#todo-define-your-sequence"
  },"40": {
    "doc": "7+8: Animistic Design",
    "title": "Define how many times the defined sequence should be repeated",
    "content": "looping = 0 # play the sequence in an endless loop forever #looping = 1 # play the sequence only once #looping = 10 # play the sequence 10 times . while True: . # Make a call to the library and request the parameters position, running, changed = vs.sequence(sequence=my_sequence, loop_max=looping) # - Position: The new value to assign to our servo # - Running: False if the sequence is finished, True if it's still running # - Changed: False if the value hasn't changed since the last function call, True if it has # See if the values changed for the next move, then do so if changed: print(f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') # ----------------------------------------------------------------| # | # Use your own Acting Machine Diagram to program your interaction | # | # ----------------------------------------------------------------| # ---------------------------------------------- # v DO NOT CHANGE ANYTHING BELOW THIS POINT v | # ---------------------------------------------- led.show() time.sleep(0.1) ``` . | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#define-how-many-times-the-defined-sequence-should-be-repeated",
    
    "relUrl": "/assignments/07+08-animistic-design/#define-how-many-times-the-defined-sequence-should-be-repeated"
  },"41": {
    "doc": "7+8: Animistic Design",
    "title": "Example Code",
    "content": "Here are some examples to get you started: . Fading and blinking a Chainable LED . Running two sequences . Trigger different sequences . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/#example-code",
    
    "relUrl": "/assignments/07+08-animistic-design/#example-code"
  },"42": {
    "doc": "7+8: Animistic Design",
    "title": "7+8: Animistic Design",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/",
    
    "relUrl": "/assignments/07+08-animistic-design/"
  },"43": {
    "doc": "3: Game Controller",
    "title": "Game Controller",
    "content": "In this week’s assignment we are going to build and embody a physical controller to control a game on our screen. ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/#game-controller",
    
    "relUrl": "/assignments/03-game-controller/#game-controller"
  },"44": {
    "doc": "3: Game Controller",
    "title": "Coding Instructions",
    "content": "In this assignment, you’ll learn how to use the usb_hid library to simulate keyboard or mouse inputs with your microcontroller. Remember that when working with keyboards, it’s important to understand how keys are mapped to characters in a specific layout, and that you have the correct layout configured in your code. Pressing a key once typically produces a single character on the screen. However, holding a key down can result in multiple repeated characters. The usb_hid library lets you simulate these behaviors with commands like keyboard.press(key) to simulate a key press and keyboard.release_all() to release all pressed keys. In this assignment you’ll also explore Python basics, such as variables, loops (while), conditional statements (if, elif, else), and working with functions. By integrating these concepts with the usb_hid library, you’ll gain the skills to create interactive devices that can simulate keyboard or mouse actions dynamically. ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/#coding-instructions",
    
    "relUrl": "/assignments/03-game-controller/#coding-instructions"
  },"45": {
    "doc": "3: Game Controller",
    "title": "Possible games you can play",
    "content": "These are just some examples of games you can play, and there are many more online (or to download). Your chosen embodiment should fit the game! . | Flappy Bird | Drift Boss | Pong Game | Crazy Flips | Canabalt | . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/#possible-games-you-can-play",
    
    "relUrl": "/assignments/03-game-controller/#possible-games-you-can-play"
  },"46": {
    "doc": "3: Game Controller",
    "title": "Coding Assignment",
    "content": "You will see that different games need different inputs. Here below we present a template with almost everything you need to make your game controller work. Although, one crucial part is missing, the part inside the while loop. Your assignment is to use the template code and the acting machine diagram here below to create a working controller. Before starting, if it’s your first time coding or has been a while since the last time, we created this page that quickly introduces you to some key coding elements: Coding instructions . | Acting Machine Diagram | . | | . Code template . | PicoExpander | BitsyExpander | . | ##--- Library Imports import time import board import digitalio # We want to emulate a keyboard interface # To do so we use the usb_hid (Human-interface device) library to send commands to our computer import usb_hid from adafruit_hid.keyboard import Keyboard from adafruit_hid.keyboard_layout_us import KeyboardLayoutUS from adafruit_hid.keycode import Keycode ##--- Defining states state_wait = 0 state_button_is_pressed = 1 current_state = 0 ##--- Keyboard variables # Define a new keyboard and set the layout to US (mostly same as the Dutch layout) keyboard = Keyboard(usb_hid.devices) keyboard_layout = KeyboardLayoutUS(keyboard) # We want to send the SPACE key when the button is pressed # For other keys search online \"Circuit Python Keycode\" key = Keycode.SPACE ##--- Button variables ## Define a new button variable and assign it to port D13 of our board button = digitalio.DigitalInOut(board.GP6) ## Define the button as an input component button.direction = digitalio.Direction.INPUT ##--- Main loop # Sleep for a bit to allow the host operating system to configure the new USB device time.sleep(1) while True: # -------------------------------------------------------------| # | # Use the Acting Machine Diagram to program your solution here | # | # -------------------------------------------------------------| # Sleep for a bit to make the keypress events occur at a human timescale # Skilled gamers can do ~7 button presses per second (says ChatGPT) time.sleep(0.143) . | ##--- Library Imports import time import board import digitalio # We want to emulate a keyboard interface # To do so we use the usb_hid (Human-interface device) library to send commands to our computer import usb_hid from adafruit_hid.keyboard import Keyboard from adafruit_hid.keyboard_layout_us import KeyboardLayoutUS from adafruit_hid.keycode import Keycode ##--- Defining states state_wait = 0 state_button_is_pressed = 1 current_state = 0 ##--- Keyboard variables # Define a new keyboard and set the layout to US (mostly same as the Dutch layout) keyboard = Keyboard(usb_hid.devices) keyboard_layout = KeyboardLayoutUS(keyboard) # We want to send the SPACE key when the button is pressed # For other keys search online \"Circuit Python Keycode\" key = Keycode.SPACE ##--- Button variables ## Define a new button variable and assign it to port D13 of our board button = digitalio.DigitalInOut(board.D13) ## Define the button as an input component button.direction = digitalio.Direction.INPUT ##--- Main loop # Sleep for a bit to allow the host operating system to configure the new USB device time.sleep(1) while True: # -------------------------------------------------------------| # | # Use the Acting Machine Diagram to program your solution here | # | # -------------------------------------------------------------| # Sleep for a bit to make the keypress events occur at a human timescale # Skilled gamers can do ~7 button presses per second (says ChatGPT) time.sleep(0.143) . | . If you are struggling with the assignment we provide the solution here below. Attention: Keep in mind that from next week on you won’t find a solution to the assignments, so you should take this opportunity to become familiar with programming concepts and try hard to make the code work. Jumping straight to the solution might seem tempting, but it’s important to work through the assignment on your own first. By skipping ahead, you’ll miss out on learning critical concepts and skills that are essential for the next stages of the course. Code solution . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/#coding-assignment",
    
    "relUrl": "/assignments/03-game-controller/#coding-assignment"
  },"47": {
    "doc": "3: Game Controller",
    "title": "Extra Challenge: Control your mouse!",
    "content": "In this week’s extra challenge you’ll explore how to use the usb_hid library to control mouse movements and simulate clicks. Here we propose a brief introduction on how to use the mouse functions from the usb_hid library: . Key Functions for Mouse Control . Mouse Clicks . | Use mouse.press(button) to simulate pressing a mouse button (e.g., Mouse.LEFT_BUTTON for the left button or Mouse.RIGHT_BUTTON for the right button). | Use mouse.release(button) to simulate releasing the button. | To ensure all buttons are released, use mouse.release_all(). | . Moving the Mouse . | Use mouse.move(x=amount, y=amount) to move the mouse pointer: . | The x parameter controls horizontal movement (positive for right, negative for left). | The y parameter controls vertical movement (positive for down, negative for up). | . | . Scrolling . | Use mouse.move(wheel=amount) to simulate scrolling the mouse wheel. Positive values scroll up, and negative values scroll down. | . Your Challenge . The previous section shows how to handle button inputs and control the mouse. Use it to try and implement your own logic to play different games from the ones listed. Have fun with this challenge, and don’t hesitate to test out creative ideas! The more you experiment, the more you’ll understand how to bring your prototypes to life. If you’re lost check the state diagram below for some inspiration on how to structure your code! . | Acting Machine Diagram | . | | . ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/#extra-challenge-control-your-mouse",
    
    "relUrl": "/assignments/03-game-controller/#extra-challenge-control-your-mouse"
  },"48": {
    "doc": "3: Game Controller",
    "title": "3: Game Controller",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/03-game-controller/",
    
    "relUrl": "/assignments/03-game-controller/"
  },"49": {
    "doc": "5: Walkie-Talkie",
    "title": "Walkie-Talkie",
    "content": "In this week’s assignment we are going to build-up from the knowledge learned last week on MQTT, and we will expand it by also publishing on the server! The goal is to build a walkie-talkie that can both send and receive messages from other boards. ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie/#walkie-talkie",
    
    "relUrl": "/assignments/05-walkie-talkie/#walkie-talkie"
  },"50": {
    "doc": "5: Walkie-Talkie",
    "title": "Coding Instructions",
    "content": "In this assignment you will learn how to publish data to an MQTT topic and revise last week’s assignment on how to process received data. When connected to an MQTT server, we can not only listen to a topic (e.g. “perlin” and “iss/distance” from last week), but also send data to it! Sending data to the MQTT broker is called “publishing” and when doing so, all devices which are connected to the topic you’re sending information to will receive the data you send. If you didn’t complete last week’s assignment, you should make sure you have done the following things before starting with this assignment: . | Follow the tutorial on how to connect your board to TUD-facility wifi here. | Download the MQTT wrapper here and put it in your lib folder. | Create a settings.py file like the one shown in step 1 - 4: Data Embodiment and add the wifi credentials. | . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie/#coding-instructions",
    
    "relUrl": "/assignments/05-walkie-talkie/#coding-instructions"
  },"51": {
    "doc": "5: Walkie-Talkie",
    "title": "Coding Assignment",
    "content": "Your goal is to implement 2 buttons and an actuator of your choice (we recommend either a piezo buzzer or a vibration motor), in the following way: . | 1 button dedicated to opening the walkie-talkie channel | 1 button to send messages on the channel | 1 actuator that is triggered when a message is received | . Remember that walkie-talkies cannot receive messages while their channel is open. Just like last week, here below we present a template with almost everything you need to make your walkie-talkie work. Although, one crucial part is missing, the part inside the while loop, you should use the acting machine diagram below the code to make your walkie-talkie work. Happy coding! . Code template . | PicoExpander | BitsyExpander | . | ##--- Library Imports import time import digitalio import board import neopixel from MQTT import Create_MQTT from settings import settings ##--- Defining states state_idle = 0 state_receive = 1 state_channel_open = 2 state_transmit = 3 current_state = 0 # Define variable to save data received from the MQTT broker last_received_value = 0 ##--- Button variables open_channel_pin = board.GP6 open_channel_button = digitalio.DigitalInOut(open_channel_pin) open_channel_button.direction = digitalio.Direction.INPUT speak_channel_pin = board.GP8 speak_button = digitalio.DigitalInOut(speak_channel_pin) speak_button.direction = digitalio.Direction.INPUT ##-- Led variables pin_leds = board.GP10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_blue = (0, 0, 255, 0) led_green = (0, 255, 0, 0) led_white = (0, 0, 0, 255) def set_led_color(color): global leds leds.fill(color) leds.show() ##--- Actuator variables actuator = digitalio.DigitalInOut(board.GP12) actuator.direction = digitalio.Direction.OUTPUT # For more information on how to use PWM check this link: # https://id-studiolab.github.io/Connected-Interaction-Kit/components/piezo-buzzer/piezo-buzzer.html#define-a-tone-using-pulse-width-modulation-pwm #actuator = pwmio.PWMOut(board.GP14, variable_frequency=True) ##--- MQTT configuration # Define variable to save data received from the MQTT broker last_received_value = 0 device_has_received_new_value = False # Method used when the board receives a message from the MQTT server. def handle_message(client, topic, msg): global last_received_value global device_has_received_new_value # Assign message received to last_received variable last_received_value = msg device_has_received_new_value = True # You can find the client Id in the settings.py this is used to identify the board client_id = settings[\"mqtt_clientid\"] # Create a mqtt connection based on the settings file. mqtt_client = Create_MQTT(client_id, handle_message) # &lt;--------------------------------------------&gt; # -- DEFINE YOUR SPEAK AND LISTEN TOPIC HERE -- # VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV # Here you should select the topic of the person you want to talk to. # Write the topic you want to send messages to. mqtt_speak_topic = \"Studio05-Lisa-WalkieTalkie\" # You should set as \"listen_topic\" their \"speak_topic\" and vice-versa mqtt_listen_topic = \"Studio05-Bram-WalkieTalkie\" # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ # &lt;--------------------------------------------&gt; # Listen for messages on the topic specified above mqtt_client.subscribe(mqtt_listen_topic) ##--- Main loop while True: try: mqtt_client.loop(0.1) except (ValueError, RuntimeError) as e: print(\"Failed to get data, retrying\\n\", e) mqtt_client.reconnect() continue # --------------------------------------------- # ^ DO NOT CHANGE ANYTHING ABOVE THIS POINT ^ | # --------------------------------------------- message = \"ping\" # Use this method to publish messages on a topic: # mqtt_client.publish(mqtt_speak_topic, message) # ----------------------------------------------------------------| # | # Use the Acting Machine Diagram to program your solution here | # | # Hint: Use of the \"device_has_received_new_value\" variable | # Use the open_channel_button and speak_button variables | # Use the led variable (copied from the reation game code) | # ----------------------------------------------------------------| # ---------------------------------------------- # v DO NOT CHANGE ANYTHING BELOW THIS POINT v | # ---------------------------------------------- device_has_received_new_value = False time.sleep(0.1) . | ##--- Library Imports import time import digitalio import board import neopixel from MQTT import Create_MQTT from settings import settings ##--- Defining states state_idle = 0 state_receive = 1 state_channel_open = 2 state_transmit = 3 current_state = 0 # Define variable to save data received from the MQTT broker last_received_value = 0 ##--- Button variables open_channel_pin = board.D13 open_channel_button = digitalio.DigitalInOut(open_channel_pin) open_channel_button.direction = digitalio.Direction.INPUT speak_channel_pin = board.D7 speak_button = digitalio.DigitalInOut(speak_channel_pin) speak_button.direction = digitalio.Direction.INPUT ##-- Led variables pin_leds = board.D3 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_blue = (0, 0, 255, 0) led_green = (0, 255, 0, 0) led_white = (0, 0, 0, 255) def set_led_color(color): global leds leds.fill(color) leds.show() ##--- Actuator variables actuator = digitalio.DigitalInOut(board.D4) actuator.direction = digitalio.Direction.OUTPUT # For more information on how to use PWM check this link: # https://id-studiolab.github.io/Connected-Interaction-Kit/components/piezo-buzzer/piezo-buzzer.html#define-a-tone-using-pulse-width-modulation-pwm #actuator = pwmio.PWMOut(board.D4, variable_frequency=True) ##--- MQTT configuration # Define variable to save data received from the MQTT broker last_received_value = 0 device_has_received_new_value = False # Method used when the board receives a message from the MQTT server. def handle_message(client, topic, msg): global last_received_value global device_has_received_new_value # Assign message received to last_received variable last_received_value = msg device_has_received_new_value = True # You can find the client Id in the settings.py this is used to identify the board client_id = settings[\"mqtt_clientid\"] # Create a mqtt connection based on the settings file. mqtt_client = Create_MQTT(client_id, handle_message) # &lt;--------------------------------------------&gt; # -- DEFINE YOUR SPEAK AND LISTEN TOPIC HERE -- # VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV # Here you should select the topic of the person you want to talk to. # Write the topic you want to send messages to. mqtt_speak_topic = \"Studio05-Lisa-WalkieTalkie\" # You should set as \"listen_topic\" their \"speak_topic\" and vice-versa mqtt_listen_topic = \"Studio05-Bram-WalkieTalkie\" # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ # &lt;--------------------------------------------&gt; # Listen for messages on the topic specified above mqtt_client.subscribe(mqtt_listen_topic) ##--- Main loop while True: try: mqtt_client.loop(0.1) except (ValueError, RuntimeError) as e: print(\"Failed to get data, retrying\\n\", e) mqtt_client.reconnect() continue # --------------------------------------------- # ^ DO NOT CHANGE ANYTHING ABOVE THIS POINT ^ | # --------------------------------------------- message = \"ping\" # Use this method to publish messages on a topic: # mqtt_client.publish(mqtt_speak_topic, message) # ----------------------------------------------------------------| # | # Use the Acting Machine Diagram to program your solution here | # | # Hint: Use of the \"device_has_received_new_value\" variable | # Use the open_channel_button and speak_button variables | # Use the led variable (copied from the reation game code) | # ----------------------------------------------------------------| # ---------------------------------------------- # v DO NOT CHANGE ANYTHING BELOW THIS POINT v | # ---------------------------------------------- device_has_received_new_value = False time.sleep(0.1) . | . | Acting Machine Diagram | . | | . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie/#coding-assignment",
    
    "relUrl": "/assignments/05-walkie-talkie/#coding-assignment"
  },"52": {
    "doc": "5: Walkie-Talkie",
    "title": "Understanding Speak and Listen Topics",
    "content": "In the code, you’ll find two variables called mqtt_speak_topic and mqtt_listen_topic. You can use them to establish communication between walkie-talkies. Speak Topic = where you send messages Listen Topic = where you receive messages . For two devices to communicate: . | Your speak topic must be your partner’s listen topic | Your listen topic must be your partner’s speak topic | . Example: . Your Device: - Speak Topic: \"Studio05-YourName-WalkieTalkie\" - Listen Topic: \"Studio05-PartnerName-WalkieTalkie\" Partner's Device: - Speak Topic: \"Studio05-PartnerName-WalkieTalkie\" - Listen Topic: \"Studio05-YourName-WalkieTalkie\" . Note: Topics must match exactly, including capitalization! . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie/#understanding-speak-and-listen-topics",
    
    "relUrl": "/assignments/05-walkie-talkie/#understanding-speak-and-listen-topics"
  },"53": {
    "doc": "5: Walkie-Talkie",
    "title": "Extra Challenge: Interpret received messages",
    "content": "In the current assignment, your walkie-talkie sends a fixed message (“ping”) each time you press the button. But real communication isn’t just about sending the same thing over and over; messages can carry different meanings! . For this challenge, modify your code so that different messages can be sent instead of always sending “ping”. Think about the different ways in which you could send different messages, for example, assign two buttons or create a switch to select messages before sending. When receiving messages, be sure that your walkie-talkie also interprets incoming messages and responds differently based on their content. Think about how this could enhance the interaction, different messages could trigger different responses from the actuator, maybe also triggering different actuators. Push yourself to explore how MQTT can be used for more dynamic communication! . Here below we provide a more advanced acting machine digram to help you create your improved walkie-talkie . | Acting Machine Diagram | . | | . ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie/#extra-challenge-interpret-received-messages",
    
    "relUrl": "/assignments/05-walkie-talkie/#extra-challenge-interpret-received-messages"
  },"54": {
    "doc": "5: Walkie-Talkie",
    "title": "5: Walkie-Talkie",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/05-walkie-talkie/",
    
    "relUrl": "/assignments/05-walkie-talkie/"
  },"55": {
    "doc": "4: Data Embodiment",
    "title": "Data Embodiment",
    "content": ". In this weeks assignment we are going to use online data to inform our design by embodying it into a physical artefact. We will use MQTT (a lightweight protocol for the Internet of Things) to provide you with multiple data sources that you can use in this assignment. The five datasources we provide are: . | The wind speed, as reported by a virtual windspeed sensor (you can decide to locate it anywhere on planet earth), it shows values between 0 km/hour and 120 km/hhour. | The length of a virtual queue at a coffee machine (which coffee machine is up to you), values are between 0 and 20 people. | The temperature measure somewhere (you can locate this sensor anywhere on planet earth too), values are between -20 and 40 degrees Celcius. | A Perlin Noise function that returns smooth values between -1 and 1. This is actually the basis of the above virtual sensors. It’s values are scaled to an appropriate range to make it meaningfull for that sensor. | The current coordinates of the ISS and its calculated distance to IDE in Delft. These values are based on an real-online datasource provided by NASA. The distance between the IDE-building and the ISS is calculated and shown, roughly between 8000 and 14000 km and the projected location on the earth surface is shown in latitude and longitude. | . You can follow the flow of data when going to https://ide-education.cloud.shiftr.io . ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/#data-embodiment",
    
    "relUrl": "/assignments/04-data-embodiment/#data-embodiment"
  },"56": {
    "doc": "4: Data Embodiment",
    "title": "Before we begin",
    "content": "For this week’s assignment, we prepared a lot of different code snippets to help you along. They are meant for you to use and modify for your specific design and device. Simple copy+pasting without a rough understanding of what you are copying will not work! . Although we will use a lot of code, you are not required to understand every little line, but rather analyse your needs and search for the specific code sample. As a prerequisite for this tutorial to work, make sure you followed and successfully completed Tutorial 4 of the Connected Interaction Kit website and connected your ItsyBitsy to the internet. Get started . If you’re unable to connect to the internet, don’t worry! We’ve provided a fallback method that allows you to use previously stored data from the same sources. This ensures you can still complete the tutorial and practice working with the data. However, it’s essential to revisit this tutorial later when you have internet access. Connecting to the MQTT server is a key part of understanding how to integrate real-time data into your prototypes. Fallback data . ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/#before-we-begin",
    
    "relUrl": "/assignments/04-data-embodiment/#before-we-begin"
  },"57": {
    "doc": "4: Data Embodiment",
    "title": "4: Data Embodiment",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/",
    
    "relUrl": "/assignments/04-data-embodiment/"
  },"58": {
    "doc": "6: Party Lamp",
    "title": "Party Lamp",
    "content": "After the challenges and struggles of working with MQTT in the last two assignments, this final assignment goes back to the roots, using only 1 button and 1 LED. This week we will use timers to create a Party Lamp with multiple modes, focusing on writing non-blocking code — that is, code that can handle multiple tasks at the same time, without pausing everything else or waiting for a result. Introducing blocking versus non-blocking code (also called multitasking): while the product exhibits animations like transitions, fading or blinking, it always remains responsive to the user. When you press the mode change button, the product should immediately respond by changing the light behavior. We will test this during studio time and perhaps in the wrap-up session. This approach is essential when working with animations, sensors, and interactive features, and it will help us create a responsive and dynamic Party Lamp. ",
    "url": "/Digital-Interfaces/test/assignments/06-party-lamp/#party-lamp",
    
    "relUrl": "/assignments/06-party-lamp/#party-lamp"
  },"59": {
    "doc": "6: Party Lamp",
    "title": "Coding instructions",
    "content": "In the code provided below, we offer two simple timer functions that allow you to create and check timers. These functions make it easy to work with time-based events in your code. Timer Functions . # -- Timer functions last_timer_mark = 0 timer_duration = 0 def start_timer(duration): # Takes duration in seconds global last_timer_mark, timer_duration last_timer_mark = time.monotonic() timer_duration = duration def is_timer_expired(): # Returns True/False return (time.monotonic() - last_timer_mark) &gt; timer_duration . Timer examples . import time start_timer(2.0) # Creates and starts a timer of 2 seconds print(is_timer_expired()) # Will print \"False\", since 2 seconds haven't passed time.sleep(3) # Wait 3 seconds print(is_timer_expired()) # Will print \"True\", since more than 2 seconds have passed . Once a timer has expired, you can always create a new timer with start_timer() — this will start a fresh timer with the duration you specify. ",
    "url": "/Digital-Interfaces/test/assignments/06-party-lamp/#coding-instructions",
    
    "relUrl": "/assignments/06-party-lamp/#coding-instructions"
  },"60": {
    "doc": "6: Party Lamp",
    "title": "Coding Assignment",
    "content": "Just like in previous weeks, we only provide a template with the components already configured and a couple of helper functions. Your goal is to use the Acting Machine Diagram below the code template to complete the part inside the while True: loop and implement a Party Lamp. The lamp should cycle between the following modes: . | Off: The LED is off. | Fade: The LED slowly fades off, then fades on again continuously. | Blink: The LED rapidly blinks on and off. | . For this assignment, we will use a Button and a neopixel LED. Be sure to check the template code to see where they should be connected. Code template . | PicoExpander | BitsyExpander | . | ##--- Main Loop import board import neopixel import digitalio import time # -- Define states state_off = 0 state_fade_in = 1 state_fade_out = 2 state_blink_on = 3 state_blink_off = 4 current_state = state_off # -- Initialize the button button = digitalio.DigitalInOut(board.GP8) button.direction = digitalio.Direction.INPUT button_released = True # -- Button debounce function def is_button_pressed(): global button_released if button.value is True and button_released is True: button_released = False return True if button.value is False: button_released = True return False # -- Initialize the NeoPixel led = neopixel.NeoPixel(board.GP10, 1, brightness=0.3, auto_write=False, pixel_order=neopixel.GRBW) # Define basic led colors led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_green = (0, 255, 0, 0) led_blue = (0, 0, 255, 0) led_white = (0, 0, 0, 255) def set_led_color(color): global led led.fill(color) led.show() # -- Timer functions last_timer_mark = 0 timer_duration = 0 def start_timer(duration): global last_timer_mark, timer_duration last_timer_mark = time.monotonic() timer_duration = duration def is_timer_expired(): return (time.monotonic() - last_timer_mark) &gt; timer_duration # Initialize timer durations fade_duration = 0.01 # Controls fade speed blink_duration = 0.2 # Controls blink speed # Controls fade in/out steps: # - low numbers: smooth transition, but slow. # - high numbers: fast transition, but rough. fade_step = 0.05 while True: # ----------------------------------------------------------------| # | # Use the Acting Machine Diagram to program your solution here | # | # Hint: you can use led.brightness to acces and change the | # ligth brightness. | # The brightness has a value between 0.0 and 1.0. | # | # ex: led.brightness = 0.5 # Sets the led to half the brightness | # | # ----------------------------------------------------------------| # ---------------------------------------------- # v DO NOT CHANGE ANYTHING BELOW THIS POINT v | # ---------------------------------------------- led.show() time.sleep(0.1) . | ##--- Main Loop import board import neopixel import digitalio import time # -- Define states state_off = 0 state_fade_in = 1 state_fade_out = 2 state_blink_on = 3 state_blink_off = 4 current_state = state_off # -- Initialize the button button = digitalio.DigitalInOut(board.D7) button.direction = digitalio.Direction.INPUT button_released = True # -- Button debounce function def is_button_pressed(): global button_released if button.value is True and button_released is True: button_released = False return True if button.value is False: button_released = True return False # -- Initialize the NeoPixel led = neopixel.NeoPixel(board.D13, 1, brightness=0.3, auto_write=False, pixel_order=neopixel.GRBW) # Define basic led colors led_off = (0, 0, 0, 0) led_red = (255, 0, 0, 0) led_green = (0, 255, 0, 0) led_blue = (0, 0, 255, 0) led_white = (0, 0, 0, 255) def set_led_color(color): global led led.fill(color) led.show() # -- Timer functions last_timer_mark = 0 timer_duration = 0 def start_timer(duration): global last_timer_mark, timer_duration last_timer_mark = time.monotonic() timer_duration = duration def is_timer_expired(): return (time.monotonic() - last_timer_mark) &gt; timer_duration # Initialize timer durations fade_duration = 0.01 # Controls fade speed blink_duration = 0.2 # Controls blink speed # Controls fade in/out steps: # - low numbers: smooth transition, but slow. # - high numbers: fast transition, but rough. fade_step = 0.05 while True: # ----------------------------------------------------------------| # | # Use the Acting Machine Diagram to program your solution here | # | # Hint: you can use led.brightness to acces and change the | # ligth brightness. | # The brightness has a value between 0.0 and 1.0. | # | # ex: led.brightness = 0.5 # Sets the led to half the brightness | # | # ----------------------------------------------------------------| # ---------------------------------------------- # v DO NOT CHANGE ANYTHING BELOW THIS POINT v | # ---------------------------------------------- led.show() time.sleep(0.1) . | . | Acting Machine Diagram | . | | . ",
    "url": "/Digital-Interfaces/test/assignments/06-party-lamp/#coding-assignment",
    
    "relUrl": "/assignments/06-party-lamp/#coding-assignment"
  },"61": {
    "doc": "6: Party Lamp",
    "title": "Extra challenge",
    "content": "Add new modes to the Party Lamp! If you manage to get the basic modes working, try extending your Party Lamp by adding more complex effects, such as: . | Rainbow mode: Slowly shifting between all colors of the rainbow. | Strobe mode: Very fast flashing (disco-style). | Special color programs: Sequences of color changes, like alternating between red and green for a Christmas effect. | . You’ll need to think carefully about how to manage the timing and transitions using your timers, while keeping everything responsive to the button press. ",
    "url": "/Digital-Interfaces/test/assignments/06-party-lamp/#extra-challenge",
    
    "relUrl": "/assignments/06-party-lamp/#extra-challenge"
  },"62": {
    "doc": "6: Party Lamp",
    "title": "6: Party Lamp",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/06-party-lamp/",
    
    "relUrl": "/assignments/06-party-lamp/"
  },"63": {
    "doc": "Assignments",
    "title": "Assignments",
    "content": "Here you will find necessary code examples and documentations for assignments of Digital Interfaces. ",
    "url": "/Digital-Interfaces/test/assignments/",
    
    "relUrl": "/assignments/"
  },"64": {
    "doc": "Coding Challenge",
    "title": "Coding Challenge - Sound sensitive light",
    "content": "This section is not a full tutorial but more a challenge of you coding skills. You will be building an increasingly more complicated sound activated LED. Every step consists of the following: . | A detailed explanation of what the end result of this step should be. | A button that leads to a page with the solution. | . We really encourage you to try before taking a peak at the hints and solution. If you get stuck on a step then don’t forget to check the solutions to a previous step before checking the solution of the current step, as it might help you solve it on your own. ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/#coding-challenge---sound-sensitive-light",
    
    "relUrl": "/tutorials/coding-challenge/#coding-challenge---sound-sensitive-light"
  },"65": {
    "doc": "Coding Challenge",
    "title": "Step 1 - Sound activated LED",
    "content": "For the first step you are going to create a sound activated LED. For this LED we will be using the Neopixel Chainable LED and the Sound Sensor. We want the sound sensor to trigger when it’s value exceeds 30000 and the led should stay on for 1 second. The color of the LED should be a dim white with the value of (0,0,0,50). Do not forget to turn of the LED at the start of you code. Show Solution . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/#step-1---sound-activated-led",
    
    "relUrl": "/tutorials/coding-challenge/#step-1---sound-activated-led"
  },"66": {
    "doc": "Coding Challenge",
    "title": "Step 2 - No sleep for the wicked",
    "content": "There is a good change that in Step 1 you used time.sleep() in order to make the LED stay on for one second. For this next step we challenge you to improve your code to no longer use any time.sleep(). Removing the time.sleep() will allow us to preform more multitasking in the next steps. Show Solution . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/#step-2---no-sleep-for-the-wicked",
    
    "relUrl": "/tutorials/coding-challenge/#step-2---no-sleep-for-the-wicked"
  },"67": {
    "doc": "Coding Challenge",
    "title": "Step 3 - Taste the rainbow",
    "content": "For this step we want to change the behaviour of the LED. Every time the sound sensor triggers, the LED should light up with a random color. An important part of this is that for every trigger it should only pick one color. Meaning that if I were to snap my fingers and it picks a color it should only pick a new color after it has become quite again (a sensor value of less than 30000). A good way to test this is by printing every color picked to the serial monitor! . Show Solution . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/#step-3---taste-the-rainbow",
    
    "relUrl": "/tutorials/coding-challenge/#step-3---taste-the-rainbow"
  },"68": {
    "doc": "Coding Challenge",
    "title": "Step 4 - Perfect Memory",
    "content": "For our final step, we are going to add a button. When the user presses the button, the following should happen: It should show every color chosen since the board started for 1 second each. After having shown all the colors, it should forget them. So, suppose the sensor has been triggered three times since the restart and shows red, purple, and orange. In that case, if the user presses the button, it should show red for one second, purple for one second, and orange for one second. You are allowed to use time.sleep() here again. Show Solution . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/#step-4---perfect-memory",
    
    "relUrl": "/tutorials/coding-challenge/#step-4---perfect-memory"
  },"69": {
    "doc": "Coding Challenge",
    "title": "Coding Challenge",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/",
    
    "relUrl": "/tutorials/coding-challenge/"
  },"70": {
    "doc": "02 Pomodoro",
    "title": "02 Pomodoro Timer",
    "content": "In this tutorial, you will learn how to build a Pomodoro Timer. The Pomodoro Technique is a time management technique that allows you to take regular breaks when working on a task. We will use CircuitPython as programming language, and use Mu Editor as our programming environment. Get Started . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/#02-pomodoro-timer",
    
    "relUrl": "/tutorials/02-pomodoro/#02-pomodoro-timer"
  },"71": {
    "doc": "02 Pomodoro",
    "title": "02 Pomodoro",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/",
    
    "relUrl": "/tutorials/02-pomodoro/"
  },"72": {
    "doc": "01 Time in CircuitPython",
    "title": "Dealing with Time in Circuit Python",
    "content": "You often need to take time into account one way or another when writing programs. The Core Module called time can help us with this! It has a few more bits of functionality than I will describe here (check the documentation if you’re interested). I will focus on the most important and fundamental functions, which are also very useful for the type of thing’s you might be doing. time.sleep(seconds_as_floating_point) [returns nothing] . This function is very easy to use and is sometimes the right approach - but often it’s not! . | This makes the processor (and hence the program) stop at that line and wait for the specified amount of time. | This is a simple way to introduce a delay of known duration between two steps. | Think of it like the count-down timer on your phone. When the code gets to that line, it set’s a timer for the specified time, then goes to sleep until the timer ‘beeps’, it which point it wakes up and keeps going. | The problem is that the processor can’t do anything else (with a few exceptions, e.g. it will still detect and count pulses using countio) during this time. So it’s a waste of processor power, and prevents the program from responding to anything else during that time. | For a sufficiently simple program the waste of time might not be an issue, and in some circumstances it’s ok that the system becomes unresponsive for a short while, so it can be a valid solution in some cases, particularly where very short delays are used. | . time.monotonic() [returns time_in_seconds_as_floating_point] or the time.monotonic_ns() [returns time_in_nanosecons_as_long_integer] . are often a better way of doing time related stuff. But it takes a little bit more thought and coding to make use of them. Calling either of these functions can be thought of as consulting a stop-watch that is always running and counting up. The actual value is meaningless because the starting point is arbitrary, but that doesn’t matter if you look at the difference between two readings taken at different times. Difference between time.monotonic() and time.monotonic_ns() . is just down to how time is represented: . | With “time.monotonic()” you get a floating point number that represents time in seconds. Having the number in seconds is often convenient, because it’s a fairly intuitive measure of time. | Due to the way floating point numbers are represented: an arbitrarily large number can be represented; but the precision that can be represented decreases as the number gets bigger. Initially you get precision of 1ms or better, but after an hour and a bit that will start decreasing (first to 2ms, then 4ms and so on). | So, if you need sub-millisecond precision, or if you need millisecond precision over fairly long periods, this is not the one to use. | With “time.monotonic_ns()” you get an integer that represents the time in nanoseconds (1 second = 1,000,000,000 nanoseconds = 1e9 nanoseconds). This is obviously a less intuitive measure of time. | Due to the way integers are handled by Python (this is not the case in many other languages like C++), there is no specific limit to the size of number that can be represented. As the number gets bigger, more and more memory will be allocated to represent it. Of course, eventually the board will run out of memory, but that would take quite an extreme situation. | So, using this approach will give you much finer time resolution that never deteriorates, but at the expense of more memory and, possibly, a slightly higher CPU load for doing the necessary sums. | Also note: even though it represents time in nanoseconds, don’t expect to be able to use resolution that fine. The CPU is only 120MHz, so each CPU clock cycle is going to take around 10ns, and most Python commands are going to take multiple clock cycles to complete. So probably stick to microseconds or longer! | . Illustrative Examples Involving Time . To illustrate these concepts, we will consider two examples: blinking an LED, and detecting a “double click” of a button. The associated programs are provided. ",
    "url": "/Digital-Interfaces/test/tutorials/01-time/#dealing-with-time-in-circuit-python",
    
    "relUrl": "/tutorials/01-time/#dealing-with-time-in-circuit-python"
  },"73": {
    "doc": "01 Time in CircuitPython",
    "title": "Example 1: Blink an LED",
    "content": "Two programs are provided, both of which make the on-board LED blink at 1Hz and 50% duty cycle (i.e. on for 500ms, off for 500ms and so on). Program 1: using time.sleep() . The first program (“LED blink using sleep.py”) does this using time.sleep(): it turns on the LED, sleeps for 500ms, turns off the LED, sleeps for 500ms and repeats. (See the detailed comments in the code for further explanation) . | This works totally fine if you just want to make one LED blink (how exciting!). | But what if you had two LEDs that you wanted to blink at different frequencies? Or what if you simply wanted the microcontroller to do something else while the LED was blinking? | In this case, both of those things would be impossible. The processor spends 99,9999…% of its time sleeping! | . # Import the required libraries: # - board: Provides pin definitions specific to the board being used. # - digitalio: Provides digital input/output functionality. # - time: Provides time-related functions, such as sleep(). import board import digitalio import time # Create a DigitalInOut object for the onboard LED, which is connected to pin D13. led = digitalio.DigitalInOut(board.D13) # Set the direction of the 'led' object as OUTPUT, allowing us to control the LED state. led.direction = digitalio.Direction.OUTPUT # Start an infinite loop to repeatedly execute the code within. while True: # Set the LED value to True, which turns it ON. led.value = True # Pause the program execution for 0.5 seconds (500 milliseconds) while the LED remains ON. time.sleep(0.5) # Set the LED value to False, which turns it OFF. led.value = False # Pause the program execution for 0.5 seconds (500 milliseconds) while the LED remains OFF. time.sleep(0.5) # The loop will repeat, causing the LED to blink on and off every half second. Program 2: using time.monotonic() . The second program (“LED blink using time monotonic.py”) achieves the same thing using time.monotonic(): it notes the last time it changed the LED state, keeps looping and checking the time, and changes the state again when enough time has passed (See the detailed comments in the code for further explanation) . | The resulting LED behaviour is identical to the previous example. | In this very simple case, the processor spends 99.999…% of its time checking the ‘stopwatch’ and calculating whether enough time has passed. | However, the key difference is that you could add much more code inside the while loop, and it would do that between ‘stopwatch checks’. As long as that code takes much less than 500ms to execute (which would almost always be the case - it’s pretty hard to keep a microcontroller busy for 500ms without telling it to wait!), then the blinking would continue. | See the third program (“LED blink using time monotonic multiple LEDs.py”) for an example where the program is extended to blink two LEDs at different frequencies, assuming one is connected to D1 and the other to D2. | . # Import the required libraries: # - board: Provides pin definitions specific to the board being used. # - digitalio: Provides digital input/output functionality. # - time: Provides time-related functions, such as monotonic() and sleep(). import board import digitalio import time # Create a DigitalInOut object for the onboard LED, which is connected to pin D13. led = digitalio.DigitalInOut(board.D13) # Set the direction of the 'led' object as OUTPUT, allowing us to control the LED state. led.direction = digitalio.Direction.OUTPUT # Set the blink rate for the LED (in seconds). In this case, 0.5 seconds. blinkRateLED = 0.5 # Initialize the LED state to False (off). led.value = False # Record the current time using time.monotonic() as the last time the LED state was changed. lastChangeTimeLED = time.monotonic() # Start an infinite loop to repeatedly execute the code within. while True: # Get the current time using time.monotonic(). timeNow = time.monotonic() # Check if the time elapsed since the last LED state change is greater than the blink rate. if timeNow - lastChangeTimeLED &gt; blinkRateLED: # Invert the LED state using the 'not' keyword. led.value = not led.value # Update the last LED state change time to the current time. lastChangeTimeLED = timeNow . ",
    "url": "/Digital-Interfaces/test/tutorials/01-time/#example-1-blink-an-led",
    
    "relUrl": "/tutorials/01-time/#example-1-blink-an-led"
  },"74": {
    "doc": "01 Time in CircuitPython",
    "title": "Example 2: Detecting “double click” of a button",
    "content": "Background information . | As an illustrative example that might also be useful at some point, here we build up to a program that can tell the difference between a “single click” and a “double click”, just like with a computer mouse. | I prototyped this using the “Touch Sensor” module from the Connected Interaction Kit. The code could also be applied to a conventional mechanical button, but some modification might be required to address the issue of “bouncing”. | . Switch bouncing . Switch bouncing, also known as contact bouncing, is a common issue in electronics where a mechanical switch’s contacts do not instantly make or break a connection when the switch is actuated. Instead, the contacts rapidly open and close several times before settling, causing multiple unintended transitions in the signal. This can lead to false readings or undesired behavior in digital circuits or microcontrollers interpreting the switch’s state. | To address this issue, switch debouncing techniques, such as software-based delays or hardware-based filters, are used to ensure stable and accurate signal transitions. | The Touch Sensor module includes hardware debouncing so it gives a very clean signal. | We won’t go further into the issue of debouncing here, so just use the Touch Sensor for now. | . Program 1: most basic way . The first program (“Button basic.py”) is just included to show the most basic way to control an LED from a button. The LED mirrors the state of the button, so it’s on while you hold the button. See comments in the program for more detailed explanation. # Import the required libraries: # - board: Provides pin definitions specific to the board being used. # - digitalio: Provides digital input/output functionality. # - time: Provides time-related functions, such as sleep(). import board import digitalio import time # Create a DigitalInOut object for the onboard LED, which is connected to pin D13. led = digitalio.DigitalInOut(board.D13) # Set the direction of the 'led' object as OUTPUT, allowing us to control the LED state. led.direction = digitalio.Direction.OUTPUT # Create a DigitalInOut object for the button, connected to pin D0. button = digitalio.DigitalInOut(board.D0) # Set the direction of the 'button' object as INPUT, allowing us to read its state. button.direction = digitalio.Direction.INPUT # Start an infinite loop to repeatedly execute the code within. while True: # Read the current button state and set the LED state to match the button state. # If the button is pressed (True), the LED will turn ON. # If the button is not pressed (False), the LED will turn OFF. led.value = button.value . Program 2: edge detection . The second program (“Button toggle single click.py) introduces the concept of edge detection. It specifically monitors to changes from low to high in the state of the button. Each time this occurs, it toggles the state of the LED (i.e. turns it on if it was off and vice versa). Again, this is explained in more detail in the comments in the code. # Import the required libraries: # - board: Provides pin definitions specific to the board being used. # - digitalio: Provides digital input/output functionality. # - time: Provides time-related functions, such as sleep(). import board import digitalio import time # Create a DigitalInOut object for the onboard LED, which is connected to pin D13. led = digitalio.DigitalInOut(board.D13) # Set the direction of the 'led' object as OUTPUT, allowing us to control the LED state. led.direction = digitalio.Direction.OUTPUT # Create a DigitalInOut object for the button, connected to pin D0. button = digitalio.DigitalInOut(board.D0) # Set the direction of the 'button' object as INPUT, allowing us to read its state. button.direction = digitalio.Direction.INPUT # Initialize variables to store the last button state and the current LED state. lastButton = False LEDstate = False # Start an infinite loop to repeatedly execute the code within. while True: # Read the current button state and store it in the newButton variable. newButton = button.value # Check for a rising edge (change from low to high) on the button input. if newButton and not lastButton: # If a rising edge is detected, toggle the LED state using the 'not' keyword. LEDstate = not LEDstate # Update the last button state to the current button state. lastButton = newButton # Set the LED state according to the value of LEDstate. led.value = LEDstate . Program 3: button toggle using time module . Finally, the third program (“Button toggle only on double click.py”) uses the time module (specifically the time.monotonic() function) to differentiate between a “double click” (two clicks in sufficiently quick succession – 250ms in the provided code) and one or more “single clicks”. It only toggles the LED state on a double click, but it prints “Single Click” or “Double Click” to the serial monitor. If you were using this as part of a larger program, you could do different actions on the single and double clicks. This one is fairly complicated, but the comments in the code explain in detail. # Import the required libraries: import board import digitalio import time # Create a DigitalInOut object for the onboard LED, connected to pin D13. led = digitalio.DigitalInOut(board.D13) led.direction = digitalio.Direction.OUTPUT # Set LED as output # Create a DigitalInOut object for the button, connected to pin D0. button = digitalio.DigitalInOut(board.D0) button.direction = digitalio.Direction.INPUT # Set button as input # Initialize variables to track button and LED state, as well as click detection lastButton = False LEDstate = False oneClick = False clickTime = 0 doubleClickWindow = 0.25 # Time window for double-click detection (in seconds) # Start an infinite loop to repeatedly execute the code within. while True: newButton = button.value # Read the current button state # Check for a rising edge (change from low to high) on the button input. if newButton and not lastButton: # If this is the first click, set oneClick to True and save the current time. if not oneClick: oneClick = True clickTime = time.monotonic() # If oneClick is already True, a second click has been detected within the time window. else: print(\"Double Click\") # Detected a double-click oneClick = False # Reset oneClick for future click detection LEDstate = not LEDstate # Toggle the LED state (if ON, turn OFF; if OFF, turn ON) # Update the last button state to the current button state. lastButton = newButton # Check if the time since the first click has exceeded the double-click window # and oneClick is still True (meaning a second click has not been detected). if time.monotonic() - clickTime &gt; doubleClickWindow and oneClick: print(\"Single Click\") # Detected a single-click oneClick = False # Reset oneClick for future click detection # Set the LED state according to the value of LEDstate. led.value = LEDstate . ",
    "url": "/Digital-Interfaces/test/tutorials/01-time/#example-2-detecting-double-click-of-a-button",
    
    "relUrl": "/tutorials/01-time/#example-2-detecting-double-click-of-a-button"
  },"75": {
    "doc": "01 Time in CircuitPython",
    "title": "01 Time in CircuitPython",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/01-time/",
    
    "relUrl": "/tutorials/01-time/"
  },"76": {
    "doc": "Tutorials",
    "title": "Tutorials",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/",
    
    "relUrl": "/tutorials/"
  },"77": {
    "doc": "Home",
    "title": "Digital Interfaces",
    "content": " ",
    "url": "/Digital-Interfaces/test/#digital-interfaces",
    
    "relUrl": "/#digital-interfaces"
  },"78": {
    "doc": "Home",
    "title": "Assignments",
    "content": "1: Digital Interfaces Safari . 2: Reaction Game . 3: Game Controller . 4: Data Embodiment . 5: Walkie-Talkie . 6: Party Lamp . 7+8: Animistic design . ",
    "url": "/Digital-Interfaces/test/#assignments",
    
    "relUrl": "/#assignments"
  },"79": {
    "doc": "Home",
    "title": "Tutorials",
    "content": "Building a Pomodoro timer . ",
    "url": "/Digital-Interfaces/test/#tutorials",
    
    "relUrl": "/#tutorials"
  },"80": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/Digital-Interfaces/test/",
    
    "relUrl": "/"
  },"81": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Triggering different sequences based on context or interaction",
    "content": "How could we trigger different sequences based on user or context interaction? In this example, we will create a little ItsyCreature that sleeps peacefully until disturbed – in that case it wakes up and gets angry at the disturbance! . Connect the Chainable LED to pin D13, the Servo Motor to pin D2 and the Touch Sensor to D3. By default, the creature will “sleep” in peace, but when touched get angry until the sensor is released again. | PicoExpander | BitsyExpander | . | ##--- Library Imports import time import board import neopixel import pwmio import digitalio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup # Add a touch sensor touch = digitalio.DigitalInOut(board.GP8) touch.direction = digitalio.Direction.INPUT pin_leds = board.GP10 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) pwm = pwmio.PWMOut(board.GP6, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence_sleep = [ (80, 3, 80, \"QuadEaseIn\"), (80, 2, 1, \"LinearInOut\"), (0, 3, 80, \"QuadEaseInOut\"), (0, 2, 1, \"LinearInOut\") ] led_sequence_angry = [ (MAX_LED, 0.01, 1, \"QuadEaseInOut\"), (MIN_LED, 0.01, 1, \"QuadEaseInOut\") ] servo_sequence_sleep = [ (0, 1.0, 1, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (0, 10.0, 11, \"LinearInOut\") ] servo_sequence_angry = [ (10, 0.01, 1, \"LinearInOut\"), (MIN_SERVO, 0.01, 1, \"LinearInOut\") ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.show() ##--- Main loop while True: if touch.value == False: print(\"sleeping 😴\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_sleep, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED White led_value = int(position_led) leds.fill((0, 0, 0, led_value)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_sleep, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo elif touch.value == True: print(\"angry!!! 😡\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_angry, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED Red led_value = int(position_led) leds.fill((led_value, 0, 0)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_angry, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo time.sleep(0.05) . | ##--- Library Imports import time import board import neopixel import pwmio import digitalio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup # Add a touch sensor touch = digitalio.DigitalInOut(board.D3) touch.direction = digitalio.Direction.INPUT pin_leds = board.D13 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence_sleep = [ (80, 3, 80, \"QuadEaseIn\"), (80, 2, 1, \"LinearInOut\"), (0, 3, 80, \"QuadEaseInOut\"), (0, 2, 1, \"LinearInOut\") ] led_sequence_angry = [ (MAX_LED, 0.01, 1, \"QuadEaseInOut\"), (MIN_LED, 0.01, 1, \"QuadEaseInOut\") ] servo_sequence_sleep = [ (0, 1.0, 1, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (0, 10.0, 11, \"LinearInOut\") ] servo_sequence_angry = [ (10, 0.01, 1, \"LinearInOut\"), (MIN_SERVO, 0.01, 1, \"LinearInOut\") ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.show() ##--- Main loop while True: if touch.value == False: print(\"sleeping 😴\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_sleep, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED White led_value = int(position_led) leds.fill((0, 0, 0, led_value)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_sleep, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo elif touch.value == True: print(\"angry!!! 😡\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_angry, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED Red led_value = int(position_led) leds.fill((led_value, 0, 0)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_angry, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo time.sleep(0.05) . | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/trigger-different-sequences/neopixel.html#triggering-different-sequences-based-on-context-or-interaction",
    
    "relUrl": "/assignments/07+08-animistic-design/trigger-different-sequences/neopixel.html#triggering-different-sequences-based-on-context-or-interaction"
  },"82": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Chainable LED ChaiNEO",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/trigger-different-sequences/neopixel.html",
    
    "relUrl": "/assignments/07+08-animistic-design/trigger-different-sequences/neopixel.html"
  },"83": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Fading and blinking a Chainable LED",
    "content": "This example used the Chainable LED of the Connected Interaction Kit, connected to D13 of the Expander Board. | PicoExpander | BitsyExpander | . | ##--- Library Imports import time import board import neopixel from varspeed import Vspeed ##--- VarSpeed Variables MIN = 0.0 # The minimum possible value of our component MAX = 1.0 # The maximum possible value of our component vs = Vspeed(init_position=MIN, result=\"float\") # init_position = initial start position // result = float, int vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # make the output of the function be within the bounds set ##--- Hardware Setup pin_leds = board.GP6 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, brightness=0.5, auto_write=False, pixel_order=neopixel.GRBW) ##--- Custom Movement Sequence # This is where we can define the brightness of our LED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] # Define what should happen when we get to the end of our sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times leds.fill((0, 255, 0)) # Color the LED green leds.show() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position, running, changed = vs.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed: print( f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') leds.brightness = position leds.show() . | ##--- Library Imports import time import board import neopixel from varspeed import Vspeed ##--- VarSpeed Variables MIN = 0.0 # The minimum possible value of our component MAX = 1.0 # The maximum possible value of our component vs = Vspeed(init_position=MIN, result=\"float\") # init_position = initial start position // result = float, int vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # make the output of the function be within the bounds set ##--- Hardware Setup pin_leds = board.D13 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, brightness=0.5, auto_write=False, pixel_order=neopixel.GRBW) ##--- Custom Movement Sequence # This is where we can define the brightness of our LED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] # Define what should happen when we get to the end of our sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times leds.fill((0, 255, 0)) # Color the LED green leds.show() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position, running, changed = vs.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed: print( f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') leds.brightness = position leds.show() . | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/neopixel.html#fading-and-blinking-a-chainable-led",
    
    "relUrl": "/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/neopixel.html#fading-and-blinking-a-chainable-led"
  },"84": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Chainable LED ChaiNEO",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/neopixel.html",
    
    "relUrl": "/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/neopixel.html"
  },"85": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Running two sequences simultaneously",
    "content": "When we want to run two sequences at the same time, for example to control a servo and an LED, we basically have to double everything from the individual sequence. In this example, we will let the Chainable LED on pin D13 blink, while we wiggle the servo motor connected to D2 . | PicoExpander | BitsyExpander | . | ##--- Library Imports import time import board import neopixel import pwmio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup pin_leds = board.GP6 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) pwm = pwmio.PWMOut(board.GP8, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX_LED, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN_LED, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Translates to: Go to value 180 within 5 seconds and 100 steps, and use a linear easing function (0, 2.0, 5, \"QuadEaseOut\"), # Translates to: Go to value 0 within 2 seconds and 5 steps, and use a QuadEaseOut easing function (90, 2.0, 10, \"SineEaseInOut\") # Translates to: Go to value 90 within 2 seconds and 10 steps, and use a SineEaseInOut easing function ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.show() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') leds.fill((int(position_led), 0, 0)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo . | ##--- Library Imports import time import board import neopixel import pwmio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup pin_leds = board.D13 num_leds = 1 leds = neopixel.NeoPixel(pin_leds, num_leds, auto_write=False, pixel_order=neopixel.GRBW) pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX_LED, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN_LED, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Translates to: Go to value 180 within 5 seconds and 100 steps, and use a linear easing function (0, 2.0, 5, \"QuadEaseOut\"), # Translates to: Go to value 0 within 2 seconds and 5 steps, and use a QuadEaseOut easing function (90, 2.0, 10, \"SineEaseInOut\") # Translates to: Go to value 90 within 2 seconds and 10 steps, and use a SineEaseInOut easing function ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.show() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') leds.fill((int(position_led), 0, 0)) leds.show() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo . | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/running-two-sequences/neopixel.html#running-two-sequences-simultaneously",
    
    "relUrl": "/assignments/07+08-animistic-design/running-two-sequences/neopixel.html#running-two-sequences-simultaneously"
  },"86": {
    "doc": "Chainable LED ChaiNEO",
    "title": "Chainable LED ChaiNEO",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/running-two-sequences/neopixel.html",
    
    "relUrl": "/assignments/07+08-animistic-design/running-two-sequences/neopixel.html"
  },"87": {
    "doc": "Fallback solution: Working with an offline fallback",
    "title": "Working with an offline fallback (Optional)",
    "content": "Designing with incoming live data is exciting, however it also makes our design susceptible for failures. What if the internet connection is disturbed? What if the server stops sending? . It can also happen that something goes wrong during our workshop, or that you have issues with connecting your ItsyBitsy to the internet. For this case, we created some offline fallbacks that allow you to learn how to embody data even if you do not manage to connect, or if you do this workshop at a different time. ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/no_internet.html#working-with-an-offline-fallback-optional",
    
    "relUrl": "/assignments/04-data-embodiment/no_internet.html#working-with-an-offline-fallback-optional"
  },"88": {
    "doc": "Fallback solution: Working with an offline fallback",
    "title": "ISS Distance and Perlin Noise Fallback",
    "content": "We saved some real data for the ISS and Perlin noise in these .txt files. This allows you to loop through the file and read the data as if it was coming from our MQTT server. | Download these two files by right-clicking and selecting \"Download linked file\" (or the equivalent of your browser): . Perlin_data.txt . ISS_distance.txt . | Add the files Perlin_data.txt and ISS_distance.txt to your CIRCUITPY device. | Create a new file called offline_data_handler.py , paste the code below into the file and save it on your CIRCUITPY device. import storage import time import random ## --- Variables interval = 1.0 # time between data points in seconds ## Choose only one file at a time datasource = \"ISS_distance.txt\" #datasource = \"Perlin_data.txt\" last_check_time = 0.0 file = open(datasource, \"r\") data = file.readlines() file.close() line_number = random.randint(0,len(data)) datapoint = 0 # We will use this value to save new incoming data incoming_value = 0 ## --- Functions def get_data_point(): global datapoint global last_check_time global data global line_number current_time = time.monotonic() if current_time &gt; last_check_time + float(interval): line_number = line_number + 1 datapoint = data[line_number] if line_number &gt;= len(data) - 1 : line_number = 0 return datapoint # --- Main loop while True: time.sleep(interval) incoming_value = get_data_point() print(incoming_value) . | Add the following line to your code.py file and save it. import offline_data_handler . | Open the Serial Monitor and you should see the collected data! | . Next Step Home . ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/no_internet.html#iss-distance-and-perlin-noise-fallback",
    
    "relUrl": "/assignments/04-data-embodiment/no_internet.html#iss-distance-and-perlin-noise-fallback"
  },"89": {
    "doc": "Fallback solution: Working with an offline fallback",
    "title": "Fallback solution: Working with an offline fallback",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/no_internet.html",
    
    "relUrl": "/assignments/04-data-embodiment/no_internet.html"
  },"90": {
    "doc": "Chainable LED P9813",
    "title": "Triggering different sequences based on context or interaction",
    "content": "How could we trigger different sequences based on user or context interaction? In this example, we will create a little ItsyCreature that sleeps peacefully until disturbed – in that case it wakes up and gets angry at the disturbance! . Connect the Chainable LED to pin D13, the Servo Motor to pin D2 and the Touch Sensor to D3. By default, the creature will “sleep” in peace, but when touched get angry until the sensor is released again. ##--- Library Imports import time import board import p9813 import pwmio import digitalio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup # Add a touch sensor touch = digitalio.DigitalInOut(board.D3) touch.direction = digitalio.Direction.INPUT pin_clk = board.D13 pin_data = board.D10 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence_sleep = [ (80, 3, 80, \"QuadEaseIn\"), (80, 2, 1, \"LinearInOut\"), (0, 3, 80, \"QuadEaseInOut\"), (0, 2, 1, \"LinearInOut\") ] led_sequence_angry = [ (MAX_LED, 0.01, 1, \"QuadEaseInOut\"), (MIN_LED, 0.01, 1, \"QuadEaseInOut\") ] servo_sequence_sleep = [ (0, 1.0, 1, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (10, 0.1, 2, \"LinearInOut\"), (0, 0.1, 2, \"LinearInOut\"), (0, 10.0, 11, \"LinearInOut\") ] servo_sequence_angry = [ (10, 0.01, 1, \"LinearInOut\"), (MIN_SERVO, 0.01, 1, \"LinearInOut\") ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.write() ##--- Main loop while True: if touch.value == False: print(\"sleeping 😴\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_sleep, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED White led_value = int(position_led) leds.fill((led_value, led_value, led_value)) leds.write() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_sleep, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo elif touch.value == True: print(\"angry!!! 😡\") # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence_angry, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: # print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') # Turn LED Red led_value = int(position_led) leds.fill((led_value, 0, 0)) leds.write() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence_angry, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: # print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo time.sleep(0.05) . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/trigger-different-sequences/p9813.html#triggering-different-sequences-based-on-context-or-interaction",
    
    "relUrl": "/assignments/07+08-animistic-design/trigger-different-sequences/p9813.html#triggering-different-sequences-based-on-context-or-interaction"
  },"91": {
    "doc": "Chainable LED P9813",
    "title": "Chainable LED P9813",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/trigger-different-sequences/p9813.html",
    
    "relUrl": "/assignments/07+08-animistic-design/trigger-different-sequences/p9813.html"
  },"92": {
    "doc": "Chainable LED P9813",
    "title": "Fading and blinking a Chainable LED (Groove)",
    "content": "This example used the Chainable LED of the Connected Interaction Kit, connected with the IN to D13 and the OUT to D10 of the Expander Board . ##--- Library Imports import time import board import p9813 from varspeed import Vspeed ##--- VarSpeed Variables MIN = 0 # The minimum possible value of our component MAX = 255 # The maximum possible value of our component vs = Vspeed(init_position=MIN, result=\"int\") # init_position = initial start position // result = float, int vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # make the output of the function be within the bounds set ##--- Hardware Setup pin_clk = board.D13 pin_data = board.D10 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] # Define what should happen when we get to the end of our sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times leds.fill((0, 0, 0)) leds.write() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position, running, changed = vs.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed: print( f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') leds.fill((int(position), 0, 0)) leds.write() . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/p9813.html#fading-and-blinking-a-chainable-led-groove",
    
    "relUrl": "/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/p9813.html#fading-and-blinking-a-chainable-led-groove"
  },"93": {
    "doc": "Chainable LED P9813",
    "title": "Chainable LED P9813",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/p9813.html",
    
    "relUrl": "/assignments/07+08-animistic-design/fading-and-blinking-a-chainable-led/p9813.html"
  },"94": {
    "doc": "Chainable LED P9813",
    "title": "Running two sequences simultaneously",
    "content": "When we want to run two sequences at the same time, for example to control a servo and an LED, we basically have to double everything from the individual sequence. In this example, we will let the Chainable LED on pin D13 blink, while we wiggle the servo motor connected to D2 . ##--- Library Imports import time import board import p9813 import pwmio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN_LED = 0 # The minimum possible value of our component MAX_LED = 255 # The maximum possible value of our component vs_led = Vspeed(init_position=MIN_LED, result=\"int\") # init_position = initial start position // result = float, int vs_led.set_bounds(lower_bound=MIN_LED, upper_bound=MAX_LED) # make the output of the function be within the bounds set MIN_SERVO = 0 # The minimum possible value of our component MAX_SERVO = 180 # The maximum possible value of our component vs_servo = Vspeed(init_position=MIN_SERVO, result=\"int\") # init_position = initial start position // result = float, int vs_servo.set_bounds(lower_bound=MIN_SERVO, upper_bound=MAX_SERVO) # make the output of the function be within the bounds set ##--- Hardware Setup pin_clk = board.D13 pin_data = board.D10 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN_SERVO # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the brightness of our LDED # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net led_sequence = [ (MAX_LED, 0.1, 5, \"QuadEaseIn\"), # Translates to: Go to the MAX value within 0.1 seconds and 5 steps, and use a QuadEaseIn easing function (MIN_LED, 1.0, 40, \"QuadEaseInOut\") # Translates to: Go to the MIN value within 1 seconds and 40 steps, and use a QuadEaseInOut easing function ] servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Translates to: Go to value 180 within 5 seconds and 100 steps, and use a linear easing function (0, 2.0, 5, \"QuadEaseOut\"), # Translates to: Go to value 0 within 2 seconds and 5 steps, and use a QuadEaseOut easing function (90, 2.0, 10, \"SineEaseInOut\") # Translates to: Go to value 90 within 2 seconds and 10 steps, and use a SineEaseInOut easing function ] # Define what should happen when we get to the end of our LED sequence led_looping = 0 # play the sequence in an endless loop forever # led_looping = 1 # play the sequence only once # led_looping = 10 # play the sequence 10 times # led_looping = 15 # play the sequence 15 times # Define what should happen when we get to the end of our servo sequence servo_looping = 0 # play the sequence in an endless loop forever # servo_looping = 1 # play the sequence only once # servo_looping = 10 # play the sequence 10 times # servo_looping = 15 # play the sequence 15 times # Set the LEDs to off leds.fill((0, 0, 0)) leds.write() ##--- Main loop while True: # Make a call to the library and request the desired of our LED position_led, running_led, changed_led = vs_led.sequence(sequence=led_sequence, loop_max=led_looping) # See if the values changed for the next move, then do so if changed_led: print(f'Sequence Num: {vs_led.seq_pos}, Step: {vs_led.step}, Position: {position_led}') leds.fill((int(position_led), 0, 0)) leds.write() # Make a call to the library and request the desired of our servo motor position_servo, running_servo, changed_servo = vs_servo.sequence(sequence=servo_sequence, loop_max=servo_looping) # See if the values changed for the next move, then do so if changed_servo: print(f'Sequence Num: {vs_servo.seq_pos}, Step: {vs_servo.step}, Position: {position_servo}') my_servo.angle = position_servo . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/running-two-sequences/p9813.html#running-two-sequences-simultaneously",
    
    "relUrl": "/assignments/07+08-animistic-design/running-two-sequences/p9813.html#running-two-sequences-simultaneously"
  },"95": {
    "doc": "Chainable LED P9813",
    "title": "Chainable LED P9813",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/running-two-sequences/p9813.html",
    
    "relUrl": "/assignments/07+08-animistic-design/running-two-sequences/p9813.html"
  },"96": {
    "doc": "Running two sequences simultaneously",
    "title": "Running two sequences simultaneously",
    "content": "When we want to run two sequences at the same time, for example to control a servo and an LED, we basically have to double everything from the individual sequence. In this example, we will let the Chainable LED on pin D13 blink, while we wiggle the servo motor connected to D2 . | Chainable RGB/W LED (ChaiNEO) | Chainable RGB LED (Grove) | . | | | . | Code | Code | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/running-two-sequences-index.html",
    
    "relUrl": "/assignments/07+08-animistic-design/running-two-sequences-index.html"
  },"97": {
    "doc": "Step 1: Code until now",
    "title": "Without Statemachine",
    "content": "import time import board import analogio import digitalio import neopixel # Register sensors sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() while True: if sound_sensor.value &gt; 30000: leds.fill(color_on) leds.show() time.sleep(1) leds.fill(color_off) leds.show() . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-1-code.html#without-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-1-code.html#without-statemachine"
  },"98": {
    "doc": "Step 1: Code until now",
    "title": "With statemachine",
    "content": "import time import board import analogio import digitalio import neopixel # States state_on = 0 state_off = 1 current_state = 0 # Register sensors sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() while True: if current_state == state_off: # make sure the LED is off leds.fill(color_off) leds.show() # check if we should turn on if sound_sensor.value &gt; 30000: current_state = state_on elif current_state == state_on: leds.fill(color_on) leds.show() time.sleep(1) current_state = state_off . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-1-code.html#with-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-1-code.html#with-statemachine"
  },"99": {
    "doc": "Step 1: Code until now",
    "title": "Step 1: Code until now",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-1-code.html",
    
    "relUrl": "/tutorials/coding-challenge/step-1-code.html"
  },"100": {
    "doc": "Setting up MQTT on your ItsyBitsy",
    "title": "Setting up MQTT on your ItsyBitsy",
    "content": "After successfully completing Tutorial 4 and connected your ItsyBitsy to the Internet, follow the steps below to establish a basic MQTT connection with our MQTT server. | Extend your settings.py file and add the entries for the MQTT broker (the server we connect to), be sure to set your username in the parameter called mqtt_clientid (please construct it as Studio[your studio]_YourName). Save the file afterwards. settings = { \"ssid\" : \"TUD-facility\", # The wifi we connect to \"password\" : \"replace-with-your-iPSK-String\", # Our personal password to connect to Wifi \"mqtt_broker\" : \"ide-education.cloud.shiftr.io\", # The MQTT server we connect to \"mqtt_user\" : \"ide-education\", # The username for connecting to the server \"mqtt_password\" : \"Sy0L85iwSSgc1P7E\", # The password for connecting to the server \"mqtt_clientid\": \"Studio5_Caspar\", # The device name we present to the server when connecting } . | We’ve created a library that helps your microcontroller connect to WiFi, connect to an MQTT broker and takes care of the details of receiving and publishing messages. Download the library using the button below, unzip it, and place the file named MQTT.py directly in the lib folder on your microcontroller. Don’t put the entire folder in lib - just the MQTT.py file itself. | . Download MQTT wrapper . If you followed the tutorial to connect to the wifi replace that code with the one below, otherwise create a new code.py copy the following code. TUD-facility can sometimes be unreliable, you can choose to use your phone hotspot instead. To do so change settings.py and set the ssid to the name of your hotspot and the password to your password. If you’re using an iPhone it is necessary that you turn on the Maximize-Compatibility option in your hotspot settings. ##--- Library Imports import time import digitalio import board from MQTT import Create_MQTT from settings import settings ##--- Defining states state_idle = 0 state_received_value = 1 current_state = 0 # Define variable to save data received from the MQTT broker last_received_value = 0 device_has_received_new_value = False ##--- MQTT Setup # Method used when the board receives # a message from the MQTT server. def handle_message(client, topic, msg): global last_received_value global device_has_received_new_value # Assign message received to last_received variable last_received_value = msg device_has_received_new_value = True # You can find the client Id in the settings.py this is used to identify the board client_id = settings[\"mqtt_clientid\"] # &lt;--------------------------------------------&gt; # -- CHOOSE YOUR LISTEN TOPIC HERE -- # VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV # Here you can choose what topic you want to subscribe to. The default is Perlin Noise. # Make sure there is only one topic active at any given time (and otherwise add a # before the one you do not want to use anymore) MQTT_topic = \"perlin\" #MQTT_topic = \"iss/distance\" #MQTT_topic = \"iss/location\" #MQTT_topic = \"coffee-waiting-line\" #MQTT_topic = \"windspeed\" #MQTT_topic = \"temperature\" # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ # &lt;--------------------------------------------&gt; # Create a mqtt connection based on the settings file. mqtt_client = Create_MQTT(client_id, handle_message) # Listen for messages on the topic specified above mqtt_client.subscribe(MQTT_topic) # --- Main loop while True: # This try / except loop is used to continuously get new data from MQTT, and reset if anything goes wrong try: mqtt_client.loop(0.1) except (ValueError, RuntimeError) as e: print(\"Failed to get data, retrying\\n\", e) mqtt_client.reconnect() continue # --------------------------------------------- # ^ DO NOT CHANGE ANYTHING ABOVE THIS POINT ^ | # --------------------------------------------- # ----------------------------------------------------------------| # | # Use the Acting Machine Diagram to program your solution here | # | # ----------------------------------------------------------------| # Example to print the received data - you may want to use this for your code solution if device_has_received_new_value == True: print(last_received_value) # ---------------------------------------------- # v DO NOT CHANGE ANYTHING BELOW THIS POINT v | # ---------------------------------------------- device_has_received_new_value = False time.sleep(0.01) . If you’re trying to use the value received from MQTT for calculations, you might encounter the following errors. | TypeError: unsupported operand type(s) for +: ‘int’ and ‘str’ | TypeError: cannot concatenate ‘str’ and ‘int’ objects | . That’s because the received value is in the form of text (string in python), so we need to convert it before we use it. | You can convert it to a whole number using: last_received_value = int(last_received_value) | Or to a decimal number using: last_received_value = float(last_received_value) | . Acting Machine Diagram . | With the code above we connect to an MQTT client, specify the topic and listen to the data being sent to it. If you want to process the data received you can use the last_received_value variable in the while True loop. | . In the next page we show some useful functions on how to process the data received. Previous Step Next Step . ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/step-1.html",
    
    "relUrl": "/assignments/04-data-embodiment/step-1.html"
  },"101": {
    "doc": "Setting up MQTT on your ItsyBitsy",
    "title": "Extra Challenge: Use Advanced Components",
    "content": "Now that you have successfully managed messages from MQTT, you can push your project further by incorporating additional components beyond the standard Connected Interaction Kit. This challenge encourages you to explore and integrate elements that can enhance the interactivity and visual appeal of your design. Below are some components you can experiment with: . | LED Strip (WS2812 / Neopixel) | LED Ring | LED Segment Bar | LCD Screen | Speaker / MP3 Player | Fans | . A basic introduction on how to use these components can be found here below: . Complete Prototyping Components List . Be creative and experiment! This challenge is about exploring new possibilities and applying what you’ve learned to enhance your project. 🚀 . ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/step-1.html#extra-challenge-use-advanced-components",
    
    "relUrl": "/assignments/04-data-embodiment/step-1.html#extra-challenge-use-advanced-components"
  },"102": {
    "doc": "Step 2: Code until now",
    "title": "Without Statemachine",
    "content": "import time import board import analogio import digitalio import neopixel # Register sensors sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 while True: # Turn on LED if sound_sensor.value &gt; 30000: leds.fill(color_on) leds.show() timer_mark = time.monotonic() # Turn LED off if time.monotonic() - timer_mark &gt;= timer_duration: leds.fill(color_off) leds.show() . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-2-code.html#without-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-2-code.html#without-statemachine"
  },"103": {
    "doc": "Step 2: Code until now",
    "title": "With statemachine",
    "content": "import time import board import analogio import digitalio import neopixel # States state_on = 0 state_off = 1 current_state = 0 # Register sensors sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 while True: if current_state == state_off: # make sure the LED is off leds.fill(color_off) leds.show() # check if we should turn on if sound_sensor.value &gt; 30000: # Start the timer! timer_mark = time.monotonic() current_state = state_on elif current_state == state_on: leds.fill(color_on) leds.show() if time.monotinic() - timer_mark &gt;= timer_duration: current_state = state_off . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-2-code.html#with-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-2-code.html#with-statemachine"
  },"104": {
    "doc": "Step 2: Code until now",
    "title": "Step 2: Code until now",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-2-code.html",
    
    "relUrl": "/tutorials/coding-challenge/step-2-code.html"
  },"105": {
    "doc": "Step 2: Interpreting data for our embodiment",
    "title": "Step 2: Interpreting data for our embodiment",
    "content": "Often we cannot use the pure data we receive from the MQTT server, but have to process it somehow to make it fit for our design. We created some helper functions and examples that you can use for this purpose: . Lists and basic functions . Add data to a list . Calculate a list average . Map a number x from one range to another . ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/step-2.html",
    
    "relUrl": "/assignments/04-data-embodiment/step-2.html"
  },"106": {
    "doc": "Step 2: Interpreting data for our embodiment",
    "title": "Lists and basic functions",
    "content": "A list is a collection of ordered elements, and it looks like this: . my_list = [3, 2, 1, 5, 4] . Lists can be manipulated using some basic functions, here below we show some very useful functions you can use while coding. my_list = [3, 2, 1, 5, 4] # Length length_of_list = len(my_list) # 5 # Sum sum_of_list = sum(my_list) # 15 # Minimum minimum_of_list = min(my_list) # 1 # Maximum maximum_of_list = max(my_list) # 5 # Append: Adds an element at the end of a list my_list.append(6) # my_list: [3, 2, 1, 5, 4, 6] # Pop: Removes the last element of the list my_list.pop() # my_list: [3, 2, 1, 5, 4] (The 6 we added before was removed) . Using these 5 basic functions here below we show how you can use them to create some useful helper functions. If you’re seeing an error that looks like this: unsupported operand type(s) for +: 'int' and 'str' then you probably need to convert your elements to numbers before adding them to your list: my_list.append(int(my_variable)) . Add data to a list . # lst: The list # x: Element we wish to add to the list # maxLength: How long we want our list to be at most. def add_to_bounded_list(lst, x, maxLength): lst.append(x) # Add x to the end of the list while len(lst) &gt; maxLength: # While the list exceeds the maximum length lst.pop(0) # Remove the first item . Code example . import time import random ## Create an empty list data_collection = [] ## When a list gets longer than this number, is starts to push first entries out and makes room for new data maximum_number_of_entries = 10 ## --- Functions # lst: The list # x: Element we wish to add to the list # maxLength: How long we want our list to be at most. def add_to_bounded_list(lst, x, maxLength): lst.append(x) # Add x to the end of the list while len(lst) &gt; maxLength: # While the list exceeds the maximum length lst.pop(0) # Remove the first item # --- Main loop while True: ## Generate a random integer between 0 and 1024 random_number = random.randint(0,1024) ## Add random_number to our list, and remove first entries when the maximum capacity is reached add_to_bounded_list(data_collection, random_number, maximum_number_of_entries) print(f\"The data list is: {data_collection}\") time.sleep(1) . Calculate a list average . # lst: Calculate average of this list def calculate_average(lst): return sum(lst) / len(lst) # To get the average of a list, we get the sum of the list (all numbers added together) and divide it by the length of the list (the amount of numbers in the list) . Code example . import time ## Creating some variables data_collection = [150,52,32,10,212,50,100] calculated_average = 0 ## --- Functions def calculate_average(lst): return sum(lst) / len(lst) # To get the average of a list, we get the sum of the list (all numbers added together) and divide it by the length of the list (the amount of numbers in the list) # --- Main loop while True: calculated_average = calculate_average(data_collection) print(f\"List average: {calculated_average}\") time.sleep(1) . ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/step-2.html#lists-and-basic-functions",
    
    "relUrl": "/assignments/04-data-embodiment/step-2.html#lists-and-basic-functions"
  },"107": {
    "doc": "Step 2: Interpreting data for our embodiment",
    "title": "Map a number from one range to another",
    "content": "Often it happens that our data has a range from 0 up to 1000, but our component only accepts values between 0 and 255. This mapping function comes very useful in those cases. Basic Function . # To map a number from one range to another, we just need to apply some math to the number. def map_to_range(x, inputMin, inputMax, outputMin, outputMax): # Calculate the size of the input range. inputSize = inputMax - inputMin # Same as previous but for the minimum and maximum we want to work towards. outputSize = outputMax - outputMin # Find how the output range scales compared to the input range. multiplier = outputSize / inputSize # If our number is at the minimum, we want it to be at 0. This makes multiplying easier. y = x - inputMin # Multiply said number by our multiplier so we get the correct range. For example a range from 0,1 turns into 0,180 by multiplying by 180. z = y * multiplier # We get the result by adding the minimum of the To to our previous result. result = z + outputMin return result . Code Example . import time ## Creating some empty variables raw_value = 0 mapped_value = 0 mapped_int = 0 ## --- Functions # To map a number from one range to another, we just need to apply some math to the number. def map_to_range(x, inputMin, inputMax, outputMin, outputMax): # Calculate the size of the input range. inputSize = inputMax - inputMin # Same as previous but for the minimum and maximum we want to work towards. outputSize = outputMax - outputMin # Find how the output range scales compared to the input range. multiplier = outputSize / inputSize # If our number is at the minimum, we want it to be at 0. This makes multiplying easier. y = x - inputMin # Multiply said number by our multiplier so we get the correct range. For example a range from 0,1 turns into 0,180 by multiplying by 180. z = y * multiplier # We get the result by adding the minimum of the To to our previous result. result = z + outputMin return result # --- Setup # --- Main loop while True: # Count up from 0 to 1024 for i in range(0, 1024, 1): raw_value = i # Map the raw_value that goes from 0 to 1024 to a new range of 0 to 255 mapped_value = map_to_range(raw_value,0,1024,0,255) # Sometimes we only need the integer and not full float number # The int() function rounds our float input either up or down mapped_int = int(mapped_value) print(f\"Raw value: {raw_value} // Mapped value: {mapped_value} // Mapped integer: {mapped_int}\") time.sleep(0.1) time.sleep(0.1) . Go back Fallback solution . ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/step-2.html#map-a-number-from-one-range-to-another",
    
    "relUrl": "/assignments/04-data-embodiment/step-2.html#map-a-number-from-one-range-to-another"
  },"108": {
    "doc": "Step 3: Code until now",
    "title": "Without Statemachine",
    "content": "import time import board import analogio import digitalio import neopixel import random # Register sensors button = digitalio.DigitalInOut(board.D4) button.direction = digitalio.Direction.INPUT sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 triggerd = False while True: # Turn on LED if sound_sensor.value &gt; 30000 and not triggerd: triggerd = True color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) leds.fill(color) leds.show() timer_mark = time.monotonic() if sound_sensor.value &lt; 30000 and triggerd: triggerd = False # Turn LED off if time.monotonic() - timer_mark &gt;= timer_duration: leds.fill(color_off) leds.show() . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-3-code.html#without-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-3-code.html#without-statemachine"
  },"109": {
    "doc": "Step 3: Code until now",
    "title": "With statemachine",
    "content": "import time import board import analogio import digitalio import neopixel import random # States state_on_loud = 0 state_on_quiete = 1 state_off = 2 current_state = state_off # Register sensors sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 color = None triggered = False while True: if current_state == state_off: # make sure the LED is off leds.fill(color_off) leds.show() # check if we should turn on if sound_sensor.value &gt; 30000: # Start the timer! color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) timer_mark = time.monotonic() current_state = state_on_loud elif current_state == state_on_loud: leds.fill(color) leds.show() if time.monotonic() - timer_mark &gt;= timer_duration: current_state = state_off elif sound_sensor.value &lt; 25000: current_state = state_on_quiete elif current_state == state_on_quiete: leds.fill(color) leds.show() if time.monotonic() - timer_mark &gt;= timer_duration: current_state = state_off elif sound_sensor.value &gt; 30000: # Her start the timer! color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) timer_mark = time.monotinic() current_state = state_on_loud . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-3-code.html#with-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-3-code.html#with-statemachine"
  },"110": {
    "doc": "Step 3: Code until now",
    "title": "Step 3: Code until now",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-3-code.html",
    
    "relUrl": "/tutorials/coding-challenge/step-3-code.html"
  },"111": {
    "doc": "Step 4: Code until now",
    "title": "Without Statemachine",
    "content": "import time import board import analogio import digitalio import neopixel import random # Register sensors button = digitalio.DigitalInOut(board.D4) button.direction = digitalio.Direction.INPUT sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 triggerd = False color_list = [] while True: # Replay if button.value is True: for color in color_list: leds.fill(color) leds.show() time.sleep(1) leds.fill(color_off) leds.show() color_list = [] # Turn on LED if sound_sensor.value &gt; 30000 and not triggerd: triggerd = True color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) print(f\"{color}\") color_list.append(color) leds.fill(color) leds.show() timer_mark = time.monotonic() # Don't over trigger time.sleep(0.2) if sound_sensor.value &lt; 30000 and triggerd: triggerd = False # Turn LED off if time.monotonic() - timer_mark &gt;= timer_duration: leds.fill(color_off) leds.show() . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-4-code.html#without-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-4-code.html#without-statemachine"
  },"112": {
    "doc": "Step 4: Code until now",
    "title": "With statemachine",
    "content": "import time import board import analogio import digitalio import neopixel import random # States state_on_loud = 0 state_on_quiete = 1 state_off = 2 state_memory = 3 current_state = state_off # Register sensors button = digitalio.DigitalInOut(board.D4) button.direction = digitalio.Direction.INPUT sound_sensor = analogio.AnalogIn(board.A0) # Register LED leds = neopixel.NeoPixel(board.D13, 1, auto_write=False, pixel_order=neopixel.GRBW) # colors color_off = (0,0,0,0) color_on = (0,0,0,10) leds.fill(color_off) leds.show() timer_mark = 0 timer_duration = 1 color = None triggered = False color_memory = [] while True: if current_state == state_off: # make sure the LED is off leds.fill(color_off) leds.show() # check if we should turn on if sound_sensor.value &gt; 30000: # Start the timer! color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) color_memory.append(color) timer_mark = time.monotonic() current_state = state_on_loud elif button.value is True: current_state = state_memory elif current_state == state_on_loud: leds.fill(color) leds.show() if time.monotonic() - timer_mark &gt;= timer_duration: current_state = state_off elif button.value is True: current_state = state_memory elif sound_sensor.value &lt; 25000: current_state = state_on_quiete elif current_state == state_on_quiete: leds.fill(color) leds.show() if time.monotonic() - timer_mark &gt;= timer_duration: current_state = state_off elif button.value is True: current_state = state_memory elif sound_sensor.value &gt; 30000: # Her start the timer! color = (random.randint(0,70),random.randint(0,70),random.randint(0,70),0) color_memory.append(color) timer_mark = time.monotonic() current_state = state_on_loud elif current_state == state_memory: for color in color_memory: leds.fill(color) leds.show() time.sleep(1) leds.fill(color_off) leds.show() color_memory = [] current_state = state_off . ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-4-code.html#with-statemachine",
    
    "relUrl": "/tutorials/coding-challenge/step-4-code.html#with-statemachine"
  },"113": {
    "doc": "Step 4: Code until now",
    "title": "Step 4: Code until now",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/coding-challenge/step-4-code.html",
    
    "relUrl": "/tutorials/coding-challenge/step-4-code.html"
  },"114": {
    "doc": "Step 4 (Example): Creating a Philips Hue Light",
    "title": "Step 4 (Example): Creating a Philips Hue Light",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/step-4-philips-hue.html",
    
    "relUrl": "/assignments/04-data-embodiment/step-4-philips-hue.html"
  },"115": {
    "doc": "Step 4 (Example): Creating a Philips Hue Light",
    "title": "Create your own Shiftr.io Environment",
    "content": ". | Go to Shiftr.io and create a new account | Deloy a new instance and open the instance in a new window. You will see a green background with our MQTT broker on top. | Create a new access token that you can use to connect new devices by clicking on the Gear Icon in the bottom right corner. | . ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/step-4-philips-hue.html#create-your-own-shiftrio-environment",
    
    "relUrl": "/assignments/04-data-embodiment/step-4-philips-hue.html#create-your-own-shiftrio-environment"
  },"116": {
    "doc": "Step 4 (Example): Creating a Philips Hue Light",
    "title": "P5 Sketch",
    "content": "You can duplicate this P5 Sketch to run it yourself, or create a new P5 environment and replace the code for the HTML and JavaScript file with the ones below: . Code for the index.html file . &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;main&gt; &lt;/main&gt; &lt;script src=\"sketch.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Code for the sketch.js file . // MQTT setup // MQTT client details: let broker = { hostname: '[YOUR SHIFTR INSTANCE].cloud.shiftr.io', port: 443 }; // MQTT client: let client; let creds = { clientID: 'color_picker', userName: '[YOUR SHIFTR USER NAME]', password: '[YOUR SHIFTR USER PASSWORD / TOKEN]' } let mqtt_topic = \"color_picker\" let colorPicker; let chosen_color let previous_color function setup() { createCanvas(400, 400); colorPicker = createColorPicker('#000000'); colorPicker.position(0, height + 5); chosen_color = colorPicker.color().toString() previous_color = chosen_color; console.log(previous_color); // MQTT setup client = new Paho.MQTT.Client(broker.hostname, Number(broker.port), creds.clientID); client.connect( { onSuccess: onConnect, userName: creds.userName, password: creds.password, useSSL: true }) frameRate(5) } function draw() { background(220); background(chosen_color); chosen_color = colorPicker.color().toString(); if(chosen_color !== previous_color){ console.log(chosen_color.toString()) previous_color = chosen_color sendMqttMessage(mqtt_topic, chosen_color) } } function onConnect() { console.log(\"connected!\") } function sendMqttMessage(topic, message) { if (client.isConnected()) { msg = new Paho.MQTT.Message(message); msg.destinationName = topic; client.send(msg); } } . ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/step-4-philips-hue.html#p5-sketch",
    
    "relUrl": "/assignments/04-data-embodiment/step-4-philips-hue.html#p5-sketch"
  },"117": {
    "doc": "Step 4 (Example): Creating a Philips Hue Light",
    "title": "CircuitPython code for the MQTT",
    "content": "# --- Imports import time import board import busio import p9813 from digitalio import DigitalInOut from adafruit_esp32spi import adafruit_esp32spi from adafruit_esp32spi import adafruit_esp32spi_wifimanager import adafruit_esp32spi.adafruit_esp32spi_socket as socket import adafruit_minimqtt.adafruit_minimqtt as MQTT import p9813 ################################################################# ################# SETTING UP WIFI AND MQTT ###################### ################################################################# # --- WIFI Setup # Get wifi details and more from a secrets.py file try: from secrets import secrets except ImportError: print(\"WiFi secrets are kept in secrets.py, please add them there!\") raise # If you have an externally connected ESP32: esp32_cs = DigitalInOut(board.D9) # Chip select pin esp32_ready = DigitalInOut(board.D11) # BUSY or READY pin esp32_reset = DigitalInOut(board.D12) # Reset pin spi = busio.SPI(board.SCK, board.MOSI, board.MISO) esp = adafruit_esp32spi.ESP_SPIcontrol(spi, esp32_cs, esp32_ready, esp32_reset) wifi = adafruit_esp32spi_wifimanager.ESPSPI_WiFiManager(esp, secrets) # --- MQTT Functions # Define callback methods which are called when events occur # pylint: disable=unused-argument, redefined-outer-name def connected(client, userdata, flags, rc): # This function will be called when the client is connected # successfully to the broker. print(\"Connected to MQTT broker! Listening for topic changes on %s\" % MQTT_topic) # Subscribe to all changes on the default MQTT topic feed. client.subscribe(MQTT_topic) def disconnected(client, userdata, rc): # This method is called when the client is disconnected print(\"Disconnected from MQTT Broker!\") def message(client, topic, message): global incoming_value \"\"\"Method callled when a client's subscribed feed has a new value. :param str topic: The topic of the feed with a new value. :param str message: The new value \"\"\" print(\"New message on topic {0}: {1}\".format(topic, message)) # New values are saved in this variable incoming_value = message # Connect to WiFi print(\"Connecting to WiFi...\") wifi.connect() print(\"Connected!\") # Initialize MQTT interface with the esp interface MQTT.set_socket(socket, esp) # Set up a MiniMQTT Client mqtt_client = MQTT.MQTT( broker=secrets[\"mqtt_broker\"], username=secrets[\"mqtt_broker_user\"], password=secrets[\"mqtt_broker_password\"], client_id = secrets[\"mqtt_clientid\"] ) # Setup the callback methods above mqtt_client.on_connect = connected mqtt_client.on_disconnect = disconnected mqtt_client.on_message = message ################################################################# ############## WRITE YOUR OWN CODE BELOW THIS LINE ############## ################################################################# # --- Variables # Here you can choose what datasource you want to subscribe to. The default is Perlin Noise. # Make sure there is only one datasource active at any given time (and otherwise add a # before the one you do not want to use anymore) #MQTT_topic = \"Perlin\" #MQTT_topic = \"ISS/distance\" #MQTT_topic = \"ISS/coordinates\" #MQTT_topic = \"Coffeemachine\" MQTT_topic = \"color_picker\" # We will use this value to save new incoming data incoming_value = 0 previous_value = 0 # Set up LED pin_clk = board.D13 pin_data = board.D10 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) ## --- Functions # --- Setup # --- Setup leds.fill((0, 0, 0)) leds.write() # Connect the client to the MQTT broker. print(\"Connecting to MQTT broker...\") mqtt_client.connect() # --- Main loop while True: # This try / except loop is used to continuously get new data from MQTT, and reset if anything goes wrong try: mqtt_client.loop() except (ValueError, RuntimeError) as e: print(\"Failed to get data, retrying\\n\", e) wifi.reset() mqtt_client.reconnect() continue # Add your own looping functions to do something with the data below this line # Let's print the incoming data in our Serial Monitor if incoming_value is not previous_value: print(incoming_value) # Create a temporary variable to store the string led_string = incoming_value # Reduce the string to only the needed values of RGB led_value = led_string.replace('rgba(', '').replace(',1)', '') # Turn it into a color array led_colors = led_value.split(',') # Assign the color value to individual variables red = int(led_colors[0]) green = int(led_colors[1]) blue = int(led_colors[2]) # Update the LED color leds.fill((red, green, blue)) leds.write() # Keep track of our color changes previous_value = incoming_value time.sleep(0.01) . ",
    "url": "/Digital-Interfaces/test/assignments/04-data-embodiment/step-4-philips-hue.html#circuitpython-code-for-the-mqtt",
    
    "relUrl": "/assignments/04-data-embodiment/step-4-philips-hue.html#circuitpython-code-for-the-mqtt"
  },"118": {
    "doc": "Step 1: Preparation",
    "title": "Step 1: Preparation",
    "content": "To follow this tutorial, you will need your ItsyBitsy, a chainable LED, a button, a buzzer, and a servo motor. You will also need materials to construct the Pomodoro Timer embodiment. These materials can be picked up at the faculty. The Pomodoro technique can be described by the following steps: . | Set the pomodoro timer. | Work on the task. | When the timer rings, stop working on the task. | Take a small break. If you’ve had three small breaks, take a longer break instead. | Repeat until task is done. | . These steps will look like this in a state diagram: . Open Mu and create a new file. Add the following template to the file: . ##--- Imports ##--- Variables ##--- Functions ##--- Acting Machine cause functions ##--- Acting machine effect functions ##--- Main loop while True: return . This template provides us with some basic organization for the programming that we will do in the following steps. Save this new file as code.py on your ItsyBitsy. If you already have a code.py file from a previous tutorial, move it over to some place on your computer so you can access it later. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step1.html",
    
    "relUrl": "/tutorials/02-pomodoro/step1.html"
  },"119": {
    "doc": "Step 2: Code until now",
    "title": "Step 2 Code until now",
    "content": "##--- Imports import digitalio import board ##--- Variables # State variables state_idle = 0 state_work = 1 current_state = state_idle # Button variables buttonpin = board.D7 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work # State Work elif current_state == state_work: if check_button_press(): print(\"Switch from Work to Idle\") current_state = state_idle . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step2-code.html#step-2-code-until-now",
    
    "relUrl": "/tutorials/02-pomodoro/step2-code.html#step-2-code-until-now"
  },"120": {
    "doc": "Step 2: Code until now",
    "title": "Step 2: Code until now",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step2-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step2-code.html"
  },"121": {
    "doc": "Step 2: Setting up the states",
    "title": "Step 2.A: Setting up the states",
    "content": "Upon startup, we would like the program to be in an idle state until the user explicitly starts the timer by means of a button press. To do so we will start with implementing two things: . | Variables and logic to handle the different states. | A button to toggle between states. | . First we need to define three variables: state_idle, state_work, and current_state. We represent the different states as integers. We can add these variables under the ##—-Variables paragraph: . ##--- Variables # State variables state_idle = 0 state_work = 1 current_state = state_idle . The integer stored in current_state can then be compared to the different states to decide what next steps to take inside the ##—- Main loop: . ##--- Main loop while True: # State Idle if current_state == state_idle: return # State Work elif current_state == state_work: return . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step2.html#step-2a-setting-up-the-states",
    
    "relUrl": "/tutorials/02-pomodoro/step2.html#step-2a-setting-up-the-states"
  },"122": {
    "doc": "Step 2: Setting up the states",
    "title": "Step 2.B: Implementing a button",
    "content": "To switch between the two states, we can add a button to our system. We’ll need to import the digitalio and board libraries to communicate with the button. ##--- Imports import digitalio import board . Connect the button to pin D7. The following variables allow for communication with the button: . ##--- Variables #... # Button variables buttonpin = board.D7 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT . We will need to create a function that can tell us when the button has been pressed. For this, we need two variables that keep track of the current and previous button states. To do this we can add two new variables in our ##—- Variables paragraph: . ##--- Variables #... current_button_state = False last_button_state = False . When the last recorded button state is false, and the current button state is true, we know the button has been pressed. To use these states we create a function to check if the button is being pressed in the ##—- Functions Paragraph: . ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press . Let’s alter the main loop in our program to switch between the two states once the button is pressed: . ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work # State Work elif current_state == state_work: if check_button_press(): print(\"Switch from Work to Idle\") current_state = state_idle . It’s time to upload your code to the ItsyBitsy and see if it works! Your code should now: . | Output a print statement once the state changes | Switch between states upon button press | . Click here to see the code you should have until now. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step2.html#step-2b-implementing-a-button",
    
    "relUrl": "/tutorials/02-pomodoro/step2.html#step-2b-implementing-a-button"
  },"123": {
    "doc": "Step 2: Setting up the states",
    "title": "Step 2: Setting up the states",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step2.html",
    
    "relUrl": "/tutorials/02-pomodoro/step2.html"
  },"124": {
    "doc": "Step 3: Code until now",
    "title": "Step 3: Code until now",
    "content": "##--- Imports import digitalio import board import p9813 ##--- Variables # State variables state_idle = 0 state_work = 1 current_state = state_idle # Button variables buttonpin = board.D7 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False # For the Chainable LED: pin_clk = board.D3 pin_data = board.D4 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) led_off = (0, 0, 0) led_red = (255, 0, 0) led_green = (0, 255, 0) led_blue = (0, 0, 255) led_yellow = (255, 255, 0) led_white = (255, 255, 255) ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.write() ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work set_led_color(led_green) # State Work elif current_state == state_work: if check_button_press(): print(\"Switch from Work to Idle\") current_state = state_idle set_led_color(led_off) . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step3-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step3-code.html"
  },"125": {
    "doc": "Step 3: Adding the LED",
    "title": "Step 3: Adding the LED",
    "content": "We can switch between two states, and the program prints some output when this switch happens. It would be nice to have a way to show the user which state the program is in now. We can make use of a LED for this. The ItsyBitsy doesn’t have a standard library that can control the Grove Chainable LEDs, so we will need to go through some additional steps for it to work. Follow the tutorial below to get things set up. Using a Grove Chainable LED on the ItsyBitsy . Now we can import the p9813 library, and use it to set up some variables to control the LED. ##--- Imports import p9813 ##--- Variables # For the Chainable LED: pin_clk = board.D3 pin_data = board.D4 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) . Attach the LED to D3. Let’s create a function that can change the LED’s color. ##--- Functions ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.write() . The LED takes RGB colors, with each channel ranging between 0 and 255. To make things easier on us, we can store some color variables to use later. ##--- Variables led_off = (0, 0, 0) led_red = (255, 0, 0) led_green = (0, 255, 0) led_blue = (0, 0, 255) led_yellow = (255, 255, 0) led_white = (255, 255, 255) . Equipped with our new variables and function, we can change the color of the led with only minimal alterations to our original main loop: . ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work set_led_color(led_green) # State Work elif current_state == state_work: if check_button_press(): print(\"Switch from Work to Idle\") current_state = state_idle set_led_color(led_off) . It’s time to upload your code to the ItsyBitsy and see if it works! Your code should now: . | Output a print statement once the state changes | Switch between states upon button press | Turn the LED green when the state changes from idle to work | Turn the LED off when the state changes from work to idle | . Click here to see the code you should have until now. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step3.html",
    
    "relUrl": "/tutorials/02-pomodoro/step3.html"
  },"126": {
    "doc": "Step 4: Code until now",
    "title": "Step 4: Code until now",
    "content": "##--- Imports import digitalio import board import p9813 import time ##--- Variables # State variables state_idle = 0 state_work = 1 current_state = state_idle # Button variables buttonpin = board.D7 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False # For the Chainable LED: pin_clk = board.D3 pin_data = board.D4 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) led_off = (0, 0, 0) led_red = (255, 0, 0) led_green = (0, 255, 0) led_blue = (0, 0, 255) led_yellow = (255, 255, 0) led_white = (255, 255, 255) # Timer variables work_duration = 5 timer_duration = 0 timer_mark = 0 ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.write() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work set_led_color(led_green) set_timer(work_duration) # State Work elif current_state == state_work: if timer_expired(): print(\"Switch from Work to Idle\") current_state = state_idle set_led_color(led_off) . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step4-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step4-code.html"
  },"127": {
    "doc": "Step 4: Creating a timer",
    "title": "Step 4: Creating a timer",
    "content": "Now we’re ready to add in the timer! Import the time library: . ##--- Imports import time . We can replace the transition from state_work to state_idle with a timer. Add the following variables to the program. work_duration stores how long we would like state_work to last. This is set to 5 seconds. timer_duration and timer_mark will be used when setting the timer. timer_mark will store the starting point of the timer. ##--- Variables # Timer variables work_duration = 5 timer_duration = 0 timer_mark = 0 . With these new variables, we can create a function that starts a new timer. We also create a new function that checks when the timer expires. ##--- Functions ##--- Acting machine effect functions def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() ##--- Acting machine cause functions def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False . After altering the main loop to incoorporate the aforementioned functions, we obtain this: . ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): print(\"Switch from Idle to Work\") current_state = state_work set_led_color(led_green) set_timer(work_duration) # State Work elif current_state == state_work: if timer_expired(): print(\"Switch from Work to Idle\") current_state = state_idle set_led_color(led_off) . Now, we can switch from state_idle to state_work with a button press. Once the button is pressed, a timer starts with the duration of work_duration. Once this timer expires, we transition back to state_idle. It’s time to upload your code to the ItsyBitsy and see if it works! Your code should now: . | Output a print statement once the state changes | Switch from state_work to state_idle when the timer expires | Switch from state_idle to state_work when the button is pressed | Turn the LED green when the state changes from idle to work | Turn the LED off when the state changes from work to idle | . Click here to see the code you should have until now. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step4.html",
    
    "relUrl": "/tutorials/02-pomodoro/step4.html"
  },"128": {
    "doc": "Step 5: Code until now",
    "title": "Step 5: Code until now",
    "content": "##--- Imports import digitalio import board import p9813 import time from analogio import AnalogOut ##--- Variables # State variables state_idle = 0 state_work = 1 state_break_alarm = 2 current_state = state_idle # Button variables buttonpin = board.D7 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False # For the Chainable LED: pin_clk = board.D3 pin_data = board.D4 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) led_off = (0, 0, 0) led_red = (255, 0, 0) led_green = (0, 255, 0) led_blue = (0, 0, 255) led_yellow = (255, 255, 0) led_white = (255, 255, 255) # Timer variables work_duration = 5 timer_duration = 0 timer_mark = 0 # Buzzer variables buzzerpin = board.A0 buzzer = AnalogOut(buzzerpin) ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.write() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def set_buzzer(value): if value == True: buzzer.value = 65535 else: buzzer.value = 0 ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) set_buzzer(True) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): current_state = state_idle set_led_color(led_off) set_buzzer(False) . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step5-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step5-code.html"
  },"129": {
    "doc": "Step 5: Adding an alarm",
    "title": "Step 5: Adding an alarm",
    "content": "Switching between states works now, as does the LED. But when the user’s worktime is over, they aren’t alerted in any way before the LED turns off and the state switches. To make the user aware of their worktime being over, we should add an alarm. First, we add a new state, state_break_alarm. When we are in state_work and the timer expires, we go to state_break_alarm. We also color the LED red. ##--- Imports from analogio import AnalogOut ##--- Variables # State variables state_break_alarm = 2 ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): current_state = state_idle set_led_color(led_off) . Now that we’ve set up the break state, we are ready to implement the actual alarm. We’ll use a buzzer for this. Attach the buzzer to A0. We’ll need to import the AnalogOut function to send information to the buzzer. Then, we also need to write a function that can turn the buzzer on and off. We will be able to pass a value on to this set_buzzer() function. If this value is True, we write 65535 to the buzzer. 65535 is the largest number (and thus, voltage) we can read or output to an Analog port. If we pass False to this function, we write 0 to the buzzer instead. ##--- Variables # Buzzer variables buzzerpin = board.A0 buzzer = AnalogOut(buzzerpin) ##--- Functions ##--- Acting machine effect functions def set_buzzer(value): if value == True: buzzer.value = 65535 else: buzzer.value = 0 . Let’s alter the main loop to incorporate the buzzer, passing True and False to the function wherever the buzzer needs to turn on and off: . ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) set_buzzer(True) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): current_state = state_idle set_led_color(led_off) set_buzzer(False) . It’s time to upload your code to the ItsyBitsy and see if it works! Your code should now: . | Turn the LED green when switching to state_work | Turn the LED red and turn on the buzzer when switching to state_break_alarm | Return to state_idle when pressing the button while in state_break_alarm | . Click here to see the code you should have until now. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step5.html",
    
    "relUrl": "/tutorials/02-pomodoro/step5.html"
  },"130": {
    "doc": "Step 6: Code until now",
    "title": "Step 6: Code until now",
    "content": "##--- Imports import digitalio import board import p9813 import time from analogio import AnalogOut ##--- Variables # State variables state_idle = 0 state_work = 1 state_break_alarm = 2 state_short_break = 3 state_work_alarm = 4 state_long_break = 5 current_state = state_idle # Button variables buttonpin = board.D7 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False # For the Chainable LED: pin_clk = board.D3 pin_data = board.D4 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) led_off = (0, 0, 0) led_red = (255, 0, 0) led_green = (0, 255, 0) led_blue = (0, 0, 255) led_yellow = (255, 255, 0) led_white = (255, 255, 255) # Timer variables work_duration = 5 short_break_duration = 3 long_break_duration = 8 timer_duration = 0 timer_mark = 0 break_counter = 0 # Buzzer variables buzzerpin = board.A0 buzzer = AnalogOut(buzzerpin) ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.write() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def set_buzzer(value): if value == True: buzzer.value = 65535 else: buzzer.value = 0 ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) set_buzzer(True) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): set_buzzer(False) if break_counter &lt; 3: current_state = state_short_break set_led_color(led_blue) set_timer(short_break_duration) break_counter = break_counter + 1 else: current_state = state_long_break set_led_color(led_white) set_timer(long_break_duration) break_counter = 0 # State Short Break elif current_state == state_short_break: if timer_expired(): current_state = state_work_alarm set_led_color(led_yellow) set_buzzer(True) # State Long Break elif current_state == state_long_break: if timer_expired(): current_state = state_idle set_led_color(led_off) set_buzzer(False) # State Work Alarm elif current_state == state_work_alarm: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step6-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step6-code.html"
  },"131": {
    "doc": "Step 6: Adding the breaks",
    "title": "Step 6: Adding the breaks",
    "content": " ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step6.html",
    
    "relUrl": "/tutorials/02-pomodoro/step6.html"
  },"132": {
    "doc": "Step 6: Adding the breaks",
    "title": "Step 6.1 Short break",
    "content": "Instead of returning to state_idle, we want to give the user a timed break, which can be either a short break or a long break. We start with the short break. Add state_short_break to your variables. When the break is over, we also want to alert the user that their break is over. This state, state_work_alarm, should also be in your list of variables. We also store its duration in a variable called short_break_duration. It is set to three seconds now: . ##--- Variables # State variables state_short_break = 3 state_work_alarm = 4 # Timer variables short_break_duration = 3 . The functions that we made in the last steps should be enough to implement the behavior we want. We need to add two more elif statements to take the two new states into account. The program should enter state_short_break when state_break_alarm is over, and go into state_work_alarm when the break is over. From state_work_alarm, it should return to state_work. We can make use of the different LED colors to differentiate between all these states. ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) set_buzzer(True) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): current_state = state_short_break set_led_color(led_blue) set_timer(short_break_duration) set_buzzer(False) # State Short Break elif current_state == state_short_break: if timer_expired(): current_state = state_work_alarm set_led_color(led_yellow) set_buzzer(True) # State Work Alarm elif current_state == state_work_alarm: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) . It’s time to upload your code to the ItsyBitsy and see if it works! Your code should now: . | Have the LED turn a different color upon entering a new state | Sound the alarm in states state_break_alarm and state_work_alarm | Give the user a timed break | . Here you can find the code we have until now: ** add link ** . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step6.html#step-61-short-break",
    
    "relUrl": "/tutorials/02-pomodoro/step6.html#step-61-short-break"
  },"133": {
    "doc": "Step 6: Adding the breaks",
    "title": "Step 6.2 Long break",
    "content": "After three short breaks, we want to give the user a long break before they have to go back to work. We need to take into account how many breaks the user has had. Create a new variable called break_counter, a new state called state_long_break, and a variable for the duration: . ##--- Variables break_counter = 0 # State variables state_long_break = 5 # Timer variables long_break_duration = 8 . Now we need to go into state_break_alarm and count the amount of times that the alarm has gone off. If this number is less than 3, we enter state_short_break. If it’s 3 or more, we reset the break_counter back to 0 and enter state_long_break. # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): set_buzzer(False) if break_counter &lt; 3: current_state = state_short_break set_led_color(led_blue) set_timer(short_break_duration) break_counter = break_counter + 1 else: current_state = state_long_break set_led_color(led_white) set_timer(long_break_duration) break_counter = 0 . Now we can add in the behavior for the long break. When the timer runs out, we want to turn off the Pomodoro timer and return to state_idle: . # State Long Break elif current_state == state_long_break: if timer_expired(): current_state = state_idle set_led_color(led_off) set_buzzer(False) . And here we have a functional Pomodoro timer! Upload your code to the ItsyBitsy and see if it works. Click here to see the code you should have until now. Next Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step6.html#step-62-long-break",
    
    "relUrl": "/tutorials/02-pomodoro/step6.html#step-62-long-break"
  },"134": {
    "doc": "Step 7: Code until now",
    "title": "Step 7: Code until now",
    "content": "##--- Imports import digitalio import board import p9813 import time from analogio import AnalogOut import pwmio from adafruit_motor import servo ##--- Variables # State variables state_idle = 0 state_work = 1 state_break_alarm = 2 state_short_break = 3 state_work_alarm = 4 state_long_break = 5 current_state = state_idle # Button variables buttonpin = board.D7 button = digitalio.DigitalInOut(buttonpin) button.direction = digitalio.Direction.INPUT current_button_state = False last_button_state = False # For the Chainable LED: pin_clk = board.D3 pin_data = board.D4 num_leds = 1 leds = p9813.P9813(pin_clk, pin_data, num_leds) led_off = (0, 0, 0) led_red = (255, 0, 0) led_green = (0, 255, 0) led_blue = (0, 0, 255) led_yellow = (255, 255, 0) led_white = (255, 255, 255) # Timer variables work_duration = 5 short_break_duration = 3 long_break_duration = 8 timer_duration = 0 timer_mark = 0 break_counter = 0 # Buzzer variables buzzerpin = board.A0 buzzer = AnalogOut(buzzerpin) # Servo variables pwm = pwmio.PWMOut(board.D13, frequency = 50) my_servo = servo.Servo(pwm) ##--- Functions ##--- Acting Machine cause functions def check_button_press(): global current_button_state, last_button_state button_press = False current_button_state = button.value if current_button_state and not last_button_state: button_press = True last_button_state = current_button_state return button_press def timer_expired(): global timer_mark, timer_duration if time.monotonic() - timer_mark &gt; timer_duration: return True else: return False ##--- Acting machine effect functions def set_led_color(color): global leds leds.fill(color) leds.write() def set_timer(duration): global timer_duration, timer_mark timer_duration = duration timer_mark = time.monotonic() def set_buzzer(value): if value == True: buzzer.value = 65535 else: buzzer.value = 0 def update_servo_angle(): current_time = time.monotonic() if current_time &lt; timer_mark + timer_duration: angle = int((current_time - timer_mark) / timer_duration * 180) my_servo.angle = angle ##--- Setup code, code that executes once at start-up ##--- Main loop while True: # State Idle if current_state == state_idle: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) # State Work elif current_state == state_work: if timer_expired(): current_state = state_break_alarm set_led_color(led_red) set_buzzer(True) # State Break Alarm elif current_state == state_break_alarm: if check_button_press(): set_buzzer(False) if break_counter &lt; 3: current_state = state_short_break set_led_color(led_blue) set_timer(short_break_duration) break_counter = break_counter + 1 else: current_state = state_long_break set_led_color(led_white) set_timer(long_break_duration) break_counter = 0 # State Short Break elif current_state == state_short_break: if timer_expired(): current_state = state_work_alarm set_led_color(led_yellow) set_buzzer(True) # State Long Break elif current_state == state_long_break: if timer_expired(): current_state = state_idle set_led_color(led_off) set_buzzer(False) # State Work Alarm elif current_state == state_work_alarm: if check_button_press(): current_state = state_work set_led_color(led_green) set_timer(work_duration) set_buzzer(False) . Return to tutorial . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step7-code.html",
    
    "relUrl": "/tutorials/02-pomodoro/step7-code.html"
  },"135": {
    "doc": "Step 7: Additional visualization using the servo",
    "title": "Step 7: Additional visualization using the servo",
    "content": "The Pomodoro timer is functional, but we can still improve on the user experience. It would be a good idea to visualize to the user how much time there is left before the next alarm goes off. We can use a servo for this, with its angle being 0 when the timer just starts, going up to 180 when the timer expires. Import the following libaries: . import pwmio from adafruit_motor import servo . Then, add the following variables to the program: . # Servo variables pwm = pwmio.PWMOut(board.D13, frequency = 50) my_servo = servo.Servo(pwm) . Attach the servo to pin D13. We can now control the servo through the my_servo variable. Let’s create a function that updates the servo’s angle. This function should look at the timer variables, timer_mark and timer_duration, as well as the current time, and map these to an angle. We do this by subtracting the minimum time value (timer_mark) from the current time. Then we divide this result by the timer’s duration. This will give us a number between 0 and 1. Multiplying this by our new maximum value, 180, will give us a number between 0 and 180, which we can use as an angle for the servo. Since we only want to use whole numbers, we cast it to an integer before saving it into the angle variable. ##--- Acting machine effect functions def update_servo_angle(): current_time = time.monotonic() if current_time &lt; timer_mark + timer_duration: angle = int((current_time - timer_mark) / timer_duration * 180) my_servo.angle = angle . We can call this function in every state we have a timer in: state_work, state_short_break, and state_long_break. Upload your code to the ItsyBitsy and see if it works. This concludes the programming part of the assignment! . Click here to see the code you should have until now. Last Step . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step7.html",
    
    "relUrl": "/tutorials/02-pomodoro/step7.html"
  },"136": {
    "doc": "Step 8 Assembling the embodiment",
    "title": "Step 8 Assembling the embodiment",
    "content": "Now with the code functioning and representing the state diagram from step 1, we can move on to giving our pomodoro timer an embodiment. Experiment with different materials, different shapes or perhaps even exchange some sensors for others to make it your own! . ",
    "url": "/Digital-Interfaces/test/tutorials/02-pomodoro/step8.html",
    
    "relUrl": "/tutorials/02-pomodoro/step8.html"
  },"137": {
    "doc": "Triggering different sequences based on context or interaction",
    "title": "Triggering different sequences based on context or interaction",
    "content": "How could we trigger different sequences based on user or context interaction? In this example, we will create a little ItsyCreature that sleeps peacefully until disturbed – in that case it wakes up and gets angry at the disturbance! . Connect the Chainable LED to pin D13, the Servo Motor to pin D2 and the Touch Sensor to D3. By default, the creature will “sleep” in peace, but when touched get angry until the sensor is released again. | Chainable RGB/W LED (ChaiNEO) | Chainable RGB LED (Grove) | . | | | . | Code | Code | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/trigger-different-sequences-index.html",
    
    "relUrl": "/assignments/07+08-animistic-design/trigger-different-sequences-index.html"
  },"138": {
    "doc": "VarSpeed Library Guide",
    "title": "VarSpeed Library Guide",
    "content": " ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/varspeed-library-guide.html",
    
    "relUrl": "/assignments/07+08-animistic-design/varspeed-library-guide.html"
  },"139": {
    "doc": "VarSpeed Library Guide",
    "title": "Download and Install",
    "content": "For the code to work, we need an additional library that helps us with controlling different sequences for LEDs, motors, etc. | Download the library here | Unzip the library and add the files varspeed.py and easing_functions.py into the lib folder of your CIRCUITPY | . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/varspeed-library-guide.html#download-and-install",
    
    "relUrl": "/assignments/07+08-animistic-design/varspeed-library-guide.html#download-and-install"
  },"140": {
    "doc": "VarSpeed Library Guide",
    "title": "Why use the VarSpeed library?",
    "content": "When trying to animate an LED, a servo motor, or any kind of actuator, we have to set its value. This might be the LED color, the motor angle, vibration strength – you name it. Usually, we would solve this manually by setting a new value and then a time.sleep() like this code that blinks the Chainable LED. # --- Main loop while True: print(\"hello world\") leds.fill((0, 0, 255)) leds.write() time.sleep(2) leds.fill((0, 0, 0)) leds.write() time.sleep(2) . The issue with this code is, that the time.sleep(2) function actually blocks our entire main loop for two seconds, before continuing. If we want to still read sensors while blinking our LED, or want to move another actuator at a different interval, we run into issues. The VarSpeed library solves this issue neatly by allowing us to define actuator behaviour in a simple way. In the code below, we can easily define a sequence of movements for our servo motor by providing four inputs: . | A target-value, | Time to get to that value (in seconds), | Number of steps to get there, | An easing function (see: easing functions) | . All this without having to worry about our code being blocked by a time.sleep() function. Take a look at the code examples to get a better understanding of the library and how you can use it to bring your creature to life! . ##--- Custom Movement Sequence # The sequence will go through each entry and move to the next entry # The sequence is defined with this format: (next-position, seconds-to-move, number-of-steps, easing-function) # Take a look at different easing functions here: https://easings.net servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Go to value 180, in 5 seconds, in 100 steps, and use a linear easing function. (0, 2.0, 5, \"QuadEaseOut\"), # Go to value 0, in 2 seconds, in 5 steps, and use a QuadEaseOut easing function (90, 2.0, 10, \"SineEaseInOut\") # Go to value 90, in 2 seconds, in 10 steps, and use a SineEaseInOut easing function ] . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/varspeed-library-guide.html#why-use-the-varspeed-library",
    
    "relUrl": "/assignments/07+08-animistic-design/varspeed-library-guide.html#why-use-the-varspeed-library"
  },"141": {
    "doc": "VarSpeed Library Guide",
    "title": "Detailed example with a servo",
    "content": "In this example we will take a detailed look at how to use the VarSpeed library to gradually move a servo. | As always, we start by importing all the libraries we need to run our code. ##--- Library Imports import time import board import pwmio from adafruit_motor import servo from varspeed import Vspeed . | Next, we need to configure the VarSpeed library and define what the minimum and maximum values of our sequence will be as well as pass these values on to the library itself. For the result we chose int because our output should only contain whole numbers. ##--- VarSpeed Variables MIN = 0 # The minimum possible value of our component MAX = 180 # The maximum possible value of our component vs = Vspeed(init_position=MIN, result=\"int\") # init_position = initial start position // result = float, int vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # make the output of the function be within the bounds set . | Afterwards we can configure our servo motor by defining the pin we connect it to (Pin D2), creating a variable for the motor we can use to steer it, and set an initial angle. If you haven’t worked with a servo before, take a look at its documentation page. | . | PicoExpander | BitsyExpander | . | ##--- Hardware Setup pwm = pwmio.PWMOut(board.GP10, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN # set the servo to a known starting point . | ##--- Hardware Setup pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN # set the servo to a known starting point . | . | Now instead of having to fiddle with code ourselves to define the motor movement, we can do so by writing it into a sequence that then gets interpreted by the VarSpeed library into the actual angle values. You can add as many entries into the servo_sequence array as you like, as well as define the servo_looping to define how often the sequence should be executed. Learn more about different looping functions here: https://easings.net . ##--- Custom Movement Sequence # This is where we can define the movement of our motor # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Go to 180, in 5 seconds, in 100 steps, using a linear function (0, 2.0, 5, \"QuadEaseOut\"), # Go to 0, in 2 seconds, in 5 steps, using a quadratic easing function (90, 2.0, 10, \"SineEaseInOut\") # Got to 90, in 2 seconds, in 10 steps, using a sine function ] # Define how many times the defined sequence should be repeated #servo_looping = 0 # play the sequence in an endless loop forever servo_looping = 1 # play the sequence only once #servo_looping = 10 # play the sequence 10 times . | The last thing to do is to add our main loop, so that the code gets executed continuously. ##--- Main loop while True: # Make a call to the library and request the desired of our servo motor position, running, changed = vs.sequence(sequence=servo_sequence, loop_max=servo_looping) # - Position: The new value to assign to our servo # - Running: False if the sequence is finished, True if it's still running # - Changed: False if the value hasn't changed since the last function call, True if it has # See if the values changed for the next move, then do so if changed: print(f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') my_servo.angle = position . Let’s have a look at the following statement: . position, running, changed = vs.sequence(sequence=servo_sequence, loop_max=servo_looping) . What happens here is that the VarSpeed library contains a function sequence() which takes two variables: the desired sequence (servo_sequence) and the amount of loops (servo_looping). It also returns three variables: . | The current position in the sequence (position) | Whether the sequence is running (running) | If the value has changed (changed) | . | . Combined together, the final code for controlling a servo motor with a sequence is this: . ##--- Library Imports import time import board import pwmio from adafruit_motor import servo from varspeed import Vspeed ##--- VarSpeed Variables MIN = 0 # The minimum possible value of our component MAX = 180 # The maximum possible value of our component vs = Vspeed(init_position=MIN, result=\"int\") # init_position = initial start position // result = float, int vs.set_bounds(lower_bound=MIN, upper_bound=MAX) # make the output of the function be within the bounds set ##--- Hardware Setup pwm = pwmio.PWMOut(board.D2, duty_cycle=2 ** 15, frequency=50) # create a PWMOut object on Pin D2. my_servo = servo.Servo(pwm) # Create a servo object, my_servo my_servo.angle = MIN # set the servo to a known starting point ##--- Custom Movement Sequence # This is where we can define the movement of our motor # The sequence will go through each entry and move to the next entry # The sequence is defined in this format: (next-position,seconds-to-move,number-of-steps,easing function) # Take a look at different easing functions here: https://easings.net servo_sequence = [ (180, 5.0, 100, \"LinearInOut\"), # Go to 180, in 5 seconds, in 100 steps, using a linear function (0, 2.0, 5, \"QuadEaseOut\"), # Go to 0, in 2 seconds, in 5 steps, using a quadratic easing function (90, 2.0, 10, \"SineEaseInOut\") # Got to 90, in 2 seconds, in 10 steps, using a sine function ] # Define how many times the defined sequence should be repeated #servo_looping = 0 # play the sequence in an endless loop forever servo_looping = 1 # play the sequence only once #servo_looping = 10 # play the sequence 10 times while True: # Make a call to the library and request the desired of our servo motor position, running, changed = vs.sequence(sequence=servo_sequence, loop_max=servo_looping) # - Position: The new value to assign to our servo # - Running: False if the sequence is finished, True if it's still running # - Changed: False if the value hasn't changed since the last function call, True if it has # See if the values changed for the next move, then do so if changed: print(f'Sequence Num: {vs.seq_pos}, Step: {vs.step}, Position: {position}') my_servo.angle = position time.sleep(0.1) . Go back to the assignment . ",
    "url": "/Digital-Interfaces/test/assignments/07+08-animistic-design/varspeed-library-guide.html#detailed-example-with-a-servo",
    
    "relUrl": "/assignments/07+08-animistic-design/varspeed-library-guide.html#detailed-example-with-a-servo"
  }
}
